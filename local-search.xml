<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java-SpringMVC3-</title>
    <link href="/2021/08/23/Java-SpringMVC3-%E6%8A%A5%E6%96%87%E8%BD%AC%E6%8D%A2%E3%80%81%E6%96%87%E4%BB%B6%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/08/23/Java-SpringMVC3-%E6%8A%A5%E6%96%87%E8%BD%AC%E6%8D%A2%E3%80%81%E6%96%87%E4%BB%B6%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="八httpmessageconverter">八、HttpMessageConverter</h1><p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文</p><p>HttpMessageConverter提供了两个注解和两个类型：<span class="citation" data-cites="RequestBody">@RequestBody</span>，<span class="citation" data-cites="ResponseBody">@ResponseBody</span>，RequestEntity，</p><p>ResponseEntity</p><h3 id="requestbody">1、<span class="citation" data-cites="RequestBody">@RequestBody</span></h3><p><span class="citation" data-cites="RequestBody可以获取请求体">@RequestBody可以获取请求体</span>，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRequestBody&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRequestBody</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String requestBody)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;requestBody:&quot;</span>+requestBody);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p>requestBody:username=admin&amp;password=123456</p><h3 id="requestentity">2、RequestEntity</h3><p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRequestEntity</span><span class="hljs-params">(RequestEntity&lt;String&gt; requestEntity)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;requestHeader:&quot;</span>+requestEntity.getHeaders());<br>    System.out.println(<span class="hljs-string">&quot;requestBody:&quot;</span>+requestEntity.getBody());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果： requestHeader:[host:&quot;localhost:8080&quot;, connection:&quot;keep-alive&quot;, content-length:&quot;27&quot;, cache-control:&quot;max-age=0&quot;, sec-ch-ua:&quot;&quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;90&quot;, &quot;Google Chrome&quot;;v=&quot;90&quot;&quot;, sec-ch-ua-mobile:&quot;?0&quot;, upgrade-insecure-requests:&quot;1&quot;, origin:&quot;http://localhost:8080&quot;, user-agent:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36&quot;] requestBody:username=admin&amp;password=123</p><h3 id="responsebody">3、<span class="citation" data-cites="ResponseBody">@ResponseBody</span></h3><p><span class="citation" data-cites="ResponseBody用于标识一个控制器方法">@ResponseBody用于标识一个控制器方法</span>，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testResponseBody&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testResponseBody</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：浏览器页面显示success</p><h3 id="springmvc处理json">4、SpringMVC处理json</h3><p><span class="citation" data-cites="ResponseBody处理json的步骤">@ResponseBody处理json的步骤</span>：</p><p>a&gt;导入jackson的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>b&gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">&lt;<span class="hljs-symbol">mvc:</span><span class="hljs-keyword">annotation</span>-<span class="hljs-title">driven</span> /&gt;<br></code></pre></td></tr></table></figure><p>c&gt;在处理器方法上使用@ResponseBody注解进行标识</p><p>d&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testResponseUser&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">testResponseUser</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">1001</span>,<span class="hljs-string">&quot;admin&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>,<span class="hljs-number">23</span>,<span class="hljs-string">&quot;男&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>浏览器的页面中展示的结果：</p><p>{&quot;id&quot;:1001,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;age&quot;:23,&quot;sex&quot;:&quot;男&quot;}</p><h3 id="springmvc处理ajax">5、SpringMVC处理ajax</h3><p>a&gt;请求超链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/testAjax&#125;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;testAjax&quot;</span>&gt;</span>testAjax<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>b&gt;通过vue和axios处理点击事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/static/js/axios.min.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> vue = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&quot;#app&quot;</span>,</span><br>        methods:&#123;<br><span class="javascript">            testAjax:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;</span><br>                axios(&#123;<br><span class="javascript">                    method:<span class="hljs-string">&quot;post&quot;</span>,</span><br>                    url:event.target.href,<br>                    params:&#123;<br><span class="javascript">                        username:<span class="hljs-string">&quot;admin&quot;</span>,</span><br><span class="javascript">                        password:<span class="hljs-string">&quot;123456&quot;</span></span><br>                    &#125;<br><span class="javascript">                &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;</span><br>                    alert(response.data);<br>                &#125;);<br>                event.preventDefault();<br>            &#125;<br>        &#125;<br>    &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>c&gt;控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testAjax&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testAjax</span><span class="hljs-params">(String username, String password)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;username:&quot;</span>+username+<span class="hljs-string">&quot;,password:&quot;</span>+password);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello,ajax&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="restcontroller注解">6、<span class="citation" data-cites="RestController注解">@RestController注解</span></h3><p><span class="citation" data-cites="RestController注解是springMVC提供的一个复合注解">@RestController注解是springMVC提供的一个复合注解</span>，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解</p><h3 id="responseentity">7、ResponseEntity</h3><p>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文</p><h1 id="九文件上传和下载">九、文件上传和下载</h1><h3 id="文件下载">1、文件下载</h3><p>使用ResponseEntity实现下载文件的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testDown&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//获取ServletContext对象</span><br>    ServletContext servletContext = session.getServletContext();<br>    <span class="hljs-comment">//获取服务器中文件的真实路径</span><br>    String realPath = servletContext.getRealPath(<span class="hljs-string">&quot;/static/img/1.jpg&quot;</span>);<br>    <span class="hljs-comment">//创建输入流</span><br>    InputStream is = <span class="hljs-keyword">new</span> FileInputStream(realPath);<br>    <span class="hljs-comment">//创建字节数组</span><br>    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[is.available()];<br>    <span class="hljs-comment">//将流读到字节数组中</span><br>    is.read(bytes);<br>    <span class="hljs-comment">//创建HttpHeaders对象设置响应头信息</span><br>    MultiValueMap&lt;String, String&gt; headers = <span class="hljs-keyword">new</span> HttpHeaders();<br>    <span class="hljs-comment">//设置要下载方式以及下载文件的名字</span><br>    headers.add(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=1.jpg&quot;</span>);<br>    <span class="hljs-comment">//设置响应状态码</span><br>    HttpStatus statusCode = HttpStatus.OK;<br>    <span class="hljs-comment">//创建ResponseEntity对象</span><br>    ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; responseEntity = <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(bytes, headers, statusCode);<br>    <span class="hljs-comment">//关闭输入流</span><br>    is.close();<br>    <span class="hljs-keyword">return</span> responseEntity;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件上传">2、文件上传</h3><p>文件上传要求form表单的请求方式必须为post，并且添加属性enctype=&quot;multipart/form-data&quot;</p><p>SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p><p>上传步骤：</p><p>a&gt;添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>b&gt;在SpringMVC的配置文件中添加配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>c&gt;控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testUp&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testUp</span><span class="hljs-params">(MultipartFile photo, HttpSession session)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">//获取上传的文件的文件名</span><br>    String fileName = photo.getOriginalFilename();<br>    <span class="hljs-comment">//处理文件重名问题</span><br>    String hzName = fileName.substring(fileName.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br>    fileName = UUID.randomUUID().toString() + hzName;<br>    <span class="hljs-comment">//获取服务器中photo目录的路径</span><br>    ServletContext servletContext = session.getServletContext();<br>    String photoPath = servletContext.getRealPath(<span class="hljs-string">&quot;photo&quot;</span>);<br>    File file = <span class="hljs-keyword">new</span> File(photoPath);<br>    <span class="hljs-keyword">if</span>(!file.exists())&#123;<br>        file.mkdir();<br>    &#125;<br>    String finalPath = photoPath + File.separator + fileName;<br>    <span class="hljs-comment">//实现上传功能</span><br>    photo.transferTo(<span class="hljs-keyword">new</span> File(finalPath));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十拦截器">十、拦截器</h1><h3 id="拦截器的配置">1、拦截器的配置</h3><p>SpringMVC中的拦截器用于拦截控制器方法的执行</p><p>SpringMVC中的拦截器需要实现HandlerInterceptor</p><p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.atguigu.interceptor.FirstInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/testRequestEntity&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="拦截器的三个抽象方法">2、拦截器的三个抽象方法</h3><p>SpringMVC中的拦截器有三个抽象方法：</p><p>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p><p>postHandle：控制器方法执行之后执行postHandle()</p><p>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</p><h3 id="多个拦截器的执行顺序">3、多个拦截器的执行顺序</h3><p>a&gt;若每个拦截器的preHandle()都返回true</p><p>此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：</p><p>preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行</p><p>b&gt;若某个拦截器的preHandle()返回了false</p><p>preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行</p><h1 id="十一异常处理器">十一、异常处理器</h1><h3 id="基于配置的异常处理">1、基于配置的异常处理</h3><p>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver</p><p>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver</p><p>SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionMappings&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        properties的键表示处理器方法执行过程中出现的异常</span><br><span class="hljs-comment">        properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span><br><span class="hljs-comment">        --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionAttribute&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="基于注解的异常处理">2、基于注解的异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@ControllerAdvice将当前类标识为异常处理的组件</span><br><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionController</span> </span>&#123;<br><br>    <span class="hljs-comment">//@ExceptionHandler用于设置所标识方法处理的异常</span><br>    <span class="hljs-meta">@ExceptionHandler(ArithmeticException.class)</span><br>    <span class="hljs-comment">//ex表示当前请求处理中出现的异常对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handleArithmeticException</span><span class="hljs-params">(Exception ex, Model model)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;ex&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十二注解配置springmvc">十二、注解配置SpringMVC</h1><p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p><h3 id="创建初始化类代替web.xml">1、创建初始化类，代替web.xml</h3><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebInit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定spring的配置类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class[]&#123;SpringConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定SpringMVC的配置类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class[]&#123;WebConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定DispatcherServlet的映射规则，即url-pattern</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加过滤器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Filter[] getServletFilters() &#123;<br>        CharacterEncodingFilter encodingFilter = <span class="hljs-keyword">new</span> CharacterEncodingFilter();<br>        encodingFilter.setEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        encodingFilter.setForceRequestEncoding(<span class="hljs-keyword">true</span>);<br>        HiddenHttpMethodFilter hiddenHttpMethodFilter = <span class="hljs-keyword">new</span> HiddenHttpMethodFilter();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建springconfig配置类代替spring的配置文件">2、创建SpringConfig配置类，代替spring的配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>&#123;<br><span class="hljs-comment">//ssm整合之后，spring的配置信息写在此类中</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建webconfig配置类代替springmvc的配置文件">3、创建WebConfig配置类，代替SpringMVC的配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">//扫描组件</span><br><span class="hljs-meta">@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)</span><br><span class="hljs-comment">//开启MVC注解驱动</span><br><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-comment">//使用默认的servlet处理静态资源</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureDefaultServletHandling</span><span class="hljs-params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;<br>        configurer.enable();<br>    &#125;<br><br>    <span class="hljs-comment">//配置文件上传解析器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonsMultipartResolver <span class="hljs-title">multipartResolver</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonsMultipartResolver();<br>    &#125;<br><br>    <span class="hljs-comment">//配置拦截器</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        FirstInterceptor firstInterceptor = <span class="hljs-keyword">new</span> FirstInterceptor();<br>        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">//配置视图控制</span><br>    <br>    <span class="hljs-comment">/*@Override</span><br><span class="hljs-comment">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="hljs-comment">        registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);</span><br><span class="hljs-comment">    &#125;*/</span><br>    <br>    <span class="hljs-comment">//配置异常映射</span><br>    <span class="hljs-comment">/*@Override</span><br><span class="hljs-comment">    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;</span><br><span class="hljs-comment">        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();</span><br><span class="hljs-comment">        Properties prop = new Properties();</span><br><span class="hljs-comment">        prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;);</span><br><span class="hljs-comment">        //设置异常映射</span><br><span class="hljs-comment">        exceptionResolver.setExceptionMappings(prop);</span><br><span class="hljs-comment">        //设置共享异常信息的键</span><br><span class="hljs-comment">        exceptionResolver.setExceptionAttribute(&quot;ex&quot;);</span><br><span class="hljs-comment">        resolvers.add(exceptionResolver);</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-comment">//配置生成模板解析器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ITemplateResolver <span class="hljs-title">templateResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();<br>        <span class="hljs-comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得</span><br>        ServletContextTemplateResolver templateResolver = <span class="hljs-keyword">new</span> ServletContextTemplateResolver(<br>                webApplicationContext.getServletContext());<br>        templateResolver.setPrefix(<span class="hljs-string">&quot;/WEB-INF/templates/&quot;</span>);<br>        templateResolver.setSuffix(<span class="hljs-string">&quot;.html&quot;</span>);<br>        templateResolver.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        templateResolver.setTemplateMode(TemplateMode.HTML);<br>        <span class="hljs-keyword">return</span> templateResolver;<br>    &#125;<br><br>    <span class="hljs-comment">//生成模板引擎并为模板引擎注入模板解析器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SpringTemplateEngine <span class="hljs-title">templateEngine</span><span class="hljs-params">(ITemplateResolver templateResolver)</span> </span>&#123;<br>        SpringTemplateEngine templateEngine = <span class="hljs-keyword">new</span> SpringTemplateEngine();<br>        templateEngine.setTemplateResolver(templateResolver);<br>        <span class="hljs-keyword">return</span> templateEngine;<br>    &#125;<br><br>    <span class="hljs-comment">//生成视图解析器并未解析器注入模板引擎</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ViewResolver <span class="hljs-title">viewResolver</span><span class="hljs-params">(SpringTemplateEngine templateEngine)</span> </span>&#123;<br>        ThymeleafViewResolver viewResolver = <span class="hljs-keyword">new</span> ThymeleafViewResolver();<br>        viewResolver.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        viewResolver.setTemplateEngine(templateEngine);<br>        <span class="hljs-keyword">return</span> viewResolver;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试功能">4、测试功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十三springmvc执行流程">十三、SpringMVC执行流程</h1><h3 id="springmvc常用组件">1、SpringMVC常用组件</h3><ul><li>DispatcherServlet：<strong>前端控制器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</p><ul><li>HandlerMapping：<strong>处理器映射器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：根据请求的url、method等信息查找Handler，即控制器方法</p><ul><li>Handler：<strong>处理器</strong>，需要工程师开发</li></ul><p>作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</p><ul><li>HandlerAdapter：<strong>处理器适配器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：通过HandlerAdapter对处理器（控制器方法）进行执行</p><ul><li>ViewResolver：<strong>视图解析器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView</p><ul><li>View：<strong>视图</strong></li></ul><p>作用：将模型数据通过页面展示给用户</p><h3 id="dispatcherservlet初始化过程">2、DispatcherServlet初始化过程</h3><p>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</p><figure><img src="https://static01.imgkr.com/temp/27b671e3adb54550898e89771f7ebdf0.png" alt="images" /><figcaption>images</figcaption></figure><h5 id="a初始化webapplicationcontext">a&gt;初始化WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">initWebApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br>    WebApplicationContext rootContext =<br>        WebApplicationContextUtils.getWebApplicationContext(getServletContext());<br>    WebApplicationContext wac = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.webApplicationContext != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// A context instance was injected at construction time -&gt; use it</span><br>        wac = <span class="hljs-keyword">this</span>.webApplicationContext;<br>        <span class="hljs-keyword">if</span> (wac <span class="hljs-keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;<br>            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;<br>            <span class="hljs-keyword">if</span> (!cwac.isActive()) &#123;<br>                <span class="hljs-comment">// The context has not yet been refreshed -&gt; provide services such as</span><br>                <span class="hljs-comment">// setting the parent context, setting the application context id, etc</span><br>                <span class="hljs-keyword">if</span> (cwac.getParent() == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// The context instance was injected without an explicit parent -&gt; set</span><br>                    <span class="hljs-comment">// the root application context (if any; may be null) as the parent</span><br>                    cwac.setParent(rootContext);<br>                &#125;<br>                configureAndRefreshWebApplicationContext(cwac);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (wac == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// No context instance was injected at construction time -&gt; see if one</span><br>        <span class="hljs-comment">// has been registered in the servlet context. If one exists, it is assumed</span><br>        <span class="hljs-comment">// that the parent context (if any) has already been set and that the</span><br>        <span class="hljs-comment">// user has performed any initialization such as setting the context id</span><br>        wac = findWebApplicationContext();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (wac == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// No context instance is defined for this servlet -&gt; create a local one</span><br>        <span class="hljs-comment">// 创建WebApplicationContext</span><br>        wac = createWebApplicationContext(rootContext);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.refreshEventReceived) &#123;<br>        <span class="hljs-comment">// Either the context is not a ConfigurableApplicationContext with refresh</span><br>        <span class="hljs-comment">// support or the context injected at construction time had already been</span><br>        <span class="hljs-comment">// refreshed -&gt; trigger initial onRefresh manually here.</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.onRefreshMonitor) &#123;<br>            <span class="hljs-comment">// 刷新WebApplicationContext</span><br>            onRefresh(wac);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.publishContext) &#123;<br>        <span class="hljs-comment">// Publish the context as a servlet context attribute.</span><br>        <span class="hljs-comment">// 将IOC容器在应用域共享</span><br>        String attrName = getServletContextAttributeName();<br>        getServletContext().setAttribute(attrName, wac);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> wac;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="b创建webapplicationcontext">b&gt;创建WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">createWebApplicationContext</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ApplicationContext parent)</span> </span>&#123;<br>    Class&lt;?&gt; contextClass = getContextClass();<br>    <span class="hljs-keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<br>            <span class="hljs-string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +<br>            <span class="hljs-string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +<br>            <span class="hljs-string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 通过反射创建 IOC 容器对象</span><br>    ConfigurableWebApplicationContext wac =<br>        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);<br><br>    wac.setEnvironment(getEnvironment());<br>    <span class="hljs-comment">// 设置父容器</span><br>    wac.setParent(parent);<br>    String configLocation = getContextConfigLocation();<br>    <span class="hljs-keyword">if</span> (configLocation != <span class="hljs-keyword">null</span>) &#123;<br>        wac.setConfigLocation(configLocation);<br>    &#125;<br>    configureAndRefreshWebApplicationContext(wac);<br><br>    <span class="hljs-keyword">return</span> wac;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="cdispatcherservlet初始化策略">c&gt;DispatcherServlet初始化策略</h5><p>FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件</p><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;<br>   initMultipartResolver(context);<br>   initLocaleResolver(context);<br>   initThemeResolver(context);<br>   initHandlerMappings(context);<br>   initHandlerAdapters(context);<br>   initHandlerExceptionResolvers(context);<br>   initRequestToViewNameTranslator(context);<br>   initViewResolvers(context);<br>   initFlashMapManager(context);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dispatcherservlet调用组件处理请求">3、DispatcherServlet调用组件处理请求</h3><h5 id="aprocessrequest">a&gt;processRequest()</h5><p>FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)</p><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br><br>    <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>    Throwable failureCause = <span class="hljs-keyword">null</span>;<br><br>    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();<br>    LocaleContext localeContext = buildLocaleContext(request);<br><br>    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();<br>    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);<br><br>    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);<br>    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="hljs-keyword">new</span> RequestBindingInterceptor());<br><br>    initContextHolders(request, localeContext, requestAttributes);<br><br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写</span><br>        doService(request, response);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (ServletException | IOException ex) &#123;<br>        failureCause = ex;<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        failureCause = ex;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">&quot;Request processing failed&quot;</span>, ex);<br>    &#125;<br><br>    <span class="hljs-keyword">finally</span> &#123;<br>        resetContextHolders(request, previousLocaleContext, previousAttributes);<br>        <span class="hljs-keyword">if</span> (requestAttributes != <span class="hljs-keyword">null</span>) &#123;<br>            requestAttributes.requestCompleted();<br>        &#125;<br>        logResult(request, response, failureCause, asyncManager);<br>        publishRequestHandledEvent(request, response, startTime, failureCause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="bdoservice">b&gt;doService()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    logRequest(request);<br><br>    <span class="hljs-comment">// Keep a snapshot of the request attributes in case of an include,</span><br>    <span class="hljs-comment">// to be able to restore the original attributes after the include.</span><br>    Map&lt;String, Object&gt; attributesSnapshot = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;<br>        attributesSnapshot = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();<br>        <span class="hljs-keyword">while</span> (attrNames.hasMoreElements()) &#123;<br>            String attrName = (String) attrNames.nextElement();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;<br>                attributesSnapshot.put(attrName, request.getAttribute(attrName));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Make framework objects available to handlers and view objects.</span><br>    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());<br>    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.localeResolver);<br>    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.themeResolver);<br>    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.flashMapManager != <span class="hljs-keyword">null</span>) &#123;<br>        FlashMap inputFlashMap = <span class="hljs-keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);<br>        <span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-keyword">null</span>) &#123;<br>            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));<br>        &#125;<br>        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> FlashMap());<br>        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-keyword">this</span>.flashMapManager);<br>    &#125;<br><br>    RequestPath requestPath = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123;<br>        requestPath = ServletRequestPathUtils.parseAndCache(request);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 处理请求和响应</span><br>        doDispatch(request, response);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;<br>            <span class="hljs-comment">// Restore the original attribute snapshot, in case of an include.</span><br>            <span class="hljs-keyword">if</span> (attributesSnapshot != <span class="hljs-keyword">null</span>) &#123;<br>                restoreAttributesAfterInclude(request, attributesSnapshot);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (requestPath != <span class="hljs-keyword">null</span>) &#123;<br>            ServletRequestPathUtils.clearParsedRequestPath(request);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="cdodispatch">c&gt;doDispatch()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    HttpServletRequest processedRequest = request;<br>    HandlerExecutionChain mappedHandler = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> multipartRequestParsed = <span class="hljs-keyword">false</span>;<br><br>    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        ModelAndView mv = <span class="hljs-keyword">null</span>;<br>        Exception dispatchException = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            processedRequest = checkMultipart(request);<br>            multipartRequestParsed = (processedRequest != request);<br><br>            <span class="hljs-comment">// Determine handler for the current request.</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            mappedHandler：调用链</span><br><span class="hljs-comment">                包含handler、interceptorList、interceptorIndex</span><br><span class="hljs-comment">            handler：浏览器发送的请求所匹配的控制器方法</span><br><span class="hljs-comment">            interceptorList：处理控制器方法的所有拦截器集合</span><br><span class="hljs-comment">            interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行</span><br><span class="hljs-comment">            */</span><br>            mappedHandler = getHandler(processedRequest);<br>            <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-keyword">null</span>) &#123;<br>                noHandlerFound(processedRequest, response);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Determine handler adapter for the current request.</span><br>           <span class="hljs-comment">// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法</span><br>            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());<br><br>            <span class="hljs-comment">// Process last-modified header, if supported by the handler.</span><br>            String method = request.getMethod();<br>            <span class="hljs-keyword">boolean</span> isGet = <span class="hljs-string">&quot;GET&quot;</span>.equals(method);<br>            <span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">&quot;HEAD&quot;</span>.equals(method)) &#123;<br>                <span class="hljs-keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 调用拦截器的preHandle()</span><br>            <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Actually invoke the handler.</span><br>            <span class="hljs-comment">// 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象</span><br>            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br><br>            <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            applyDefaultViewName(processedRequest, mv);<br>            <span class="hljs-comment">// 调用拦截器的postHandle()</span><br>            mappedHandler.applyPostHandle(processedRequest, response, mv);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            dispatchException = ex;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>            <span class="hljs-comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span><br>            <span class="hljs-comment">// making them available for @ExceptionHandler methods and other scenarios.</span><br>            dispatchException = <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">&quot;Handler dispatch failed&quot;</span>, err);<br>        &#125;<br>        <span class="hljs-comment">// 后续处理：处理模型数据和渲染视图</span><br>        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>        triggerAfterCompletion(processedRequest, response, mappedHandler,<br>                               <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">&quot;Handler processing failed&quot;</span>, err));<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>            <span class="hljs-comment">// Instead of postHandle and afterCompletion</span><br>            <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) &#123;<br>                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Clean up any resources used by a multipart request.</span><br>            <span class="hljs-keyword">if</span> (multipartRequestParsed) &#123;<br>                cleanupMultipart(processedRequest);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dprocessdispatchresult">d&gt;processDispatchResult()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processDispatchResult</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   <span class="hljs-meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="hljs-meta">@Nullable</span> ModelAndView mv,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   <span class="hljs-meta">@Nullable</span> Exception exception)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    <span class="hljs-keyword">boolean</span> errorView = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> ModelAndViewDefiningException) &#123;<br>            logger.debug(<span class="hljs-string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);<br>            mv = ((ModelAndViewDefiningException) exception).getModelAndView();<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            Object handler = (mappedHandler != <span class="hljs-keyword">null</span> ? mappedHandler.getHandler() : <span class="hljs-keyword">null</span>);<br>            mv = processHandlerException(request, response, handler, exception);<br>            errorView = (mv != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Did the handler return a view to render?</span><br>    <span class="hljs-keyword">if</span> (mv != <span class="hljs-keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;<br>        <span class="hljs-comment">// 处理模型数据和渲染视图</span><br>        render(mv, request, response);<br>        <span class="hljs-keyword">if</span> (errorView) &#123;<br>            WebUtils.clearErrorRequestAttributes(request);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;<br>        <span class="hljs-comment">// Concurrent handling started during a forward</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// Exception (if any) is already handled..</span><br>        <span class="hljs-comment">// 调用拦截器的afterCompletion()</span><br>        mappedHandler.triggerAfterCompletion(request, response, <span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="springmvc的执行流程">4、SpringMVC的执行流程</h3><ol type="1"><li><p>用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。</p></li><li><p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：</p></li></ol><ol type="a"><li>不存在</li></ol><ol type="i"><li><p>再判断是否配置了mvc:default-servlet-handler</p></li><li><p>如果没配置，则控制台报映射查找不到，客户端展示404错误</p></li></ol><figure><img src="https://static01.imgkr.com/temp/c33e73624b484a198512bc366e2848aa.png" alt="image-20210709214911404" /><figcaption>image-20210709214911404</figcaption></figure><figure><img src="https://static01.imgkr.com/temp/fe4b19206efd49a293af61c47f32e810.png" alt="image-20210709214947432" /><figcaption>image-20210709214947432</figcaption></figure><ol start="3" type="i"><li>如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误</li></ol><figure><img src="https://static01.imgkr.com/temp/93ea67134f29466bbb3b74efee4564c7.png" alt="image-20210709215255693" /><figcaption>image-20210709215255693</figcaption></figure><figure><img src="https://static01.imgkr.com/temp/2de00abdde1a4dee9497232476bedd4c.png" alt="image-20210709215336097" /><figcaption>image-20210709215336097</figcaption></figure><ol start="2" type="a"><li>存在则执行下面的流程</li></ol><ol start="3" type="1"><li><p>根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。</p></li><li><p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。</p></li><li><p>如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】</p></li><li><p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p></li></ol><ol type="a"><li><p>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p></li><li><p>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</p></li><li><p>数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p></li><li><p>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p></li></ol><ol start="7" type="1"><li><p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。</p></li><li><p>此时将开始执行拦截器的postHandle(...)方法【逆向】。</p></li><li><p>根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。</p></li><li><p>渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。</p></li><li><p>将渲染结果返回给客户端。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java-SpringMVC</title>
    <link href="/2021/08/22/Java-SpringMVC2-%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81RESTful/"/>
    <url>/2021/08/22/Java-SpringMVC2-%E5%9F%9F%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81RESTful/</url>
    
    <content type="html"><![CDATA[<h1 id="五、域对象共享数据"><a href="#五、域对象共享数据" class="headerlink" title="五、域对象共享数据"></a>五、域对象共享数据</h1><h3 id="1、使用ServletAPI向request域对象共享数据"><a href="#1、使用ServletAPI向request域对象共享数据" class="headerlink" title="1、使用ServletAPI向request域对象共享数据"></a>1、使用ServletAPI向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testServletAPI&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testServletAPI</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>    request.setAttribute(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello,servletAPI&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、使用ModelAndView向request域对象共享数据"><a href="#2、使用ModelAndView向request域对象共享数据" class="headerlink" title="2、使用ModelAndView向request域对象共享数据"></a>2、使用ModelAndView向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testModelAndView&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">testModelAndView</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ModelAndView有Model和View的功能</span><br><span class="hljs-comment">     * Model主要用于向请求域共享数据</span><br><span class="hljs-comment">     * View主要用于设置视图，实现页面跳转</span><br><span class="hljs-comment">     */</span><br>    ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView();<br>    <span class="hljs-comment">//向请求域共享数据</span><br>    mav.addObject(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello,ModelAndView&quot;</span>);<br>    <span class="hljs-comment">//设置视图，实现页面跳转</span><br>    mav.setViewName(<span class="hljs-string">&quot;success&quot;</span>);<br>    <span class="hljs-keyword">return</span> mav;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、使用Model向request域对象共享数据"><a href="#3、使用Model向request域对象共享数据" class="headerlink" title="3、使用Model向request域对象共享数据"></a>3、使用Model向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testModel&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testModel</span><span class="hljs-params">(Model model)</span></span>&#123;<br>    model.addAttribute(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello,Model&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、使用map向request域对象共享数据"><a href="#4、使用map向request域对象共享数据" class="headerlink" title="4、使用map向request域对象共享数据"></a>4、使用map向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testMap&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testMap</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>&#123;<br>    map.put(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello,Map&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、使用ModelMap向request域对象共享数据"><a href="#5、使用ModelMap向request域对象共享数据" class="headerlink" title="5、使用ModelMap向request域对象共享数据"></a>5、使用ModelMap向request域对象共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testModelMap&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testModelMap</span><span class="hljs-params">(ModelMap modelMap)</span></span>&#123;<br>    modelMap.addAttribute(<span class="hljs-string">&quot;testScope&quot;</span>, <span class="hljs-string">&quot;hello,ModelMap&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、Model、ModelMap、Map的关系"><a href="#6、Model、ModelMap、Map的关系" class="headerlink" title="6、Model、ModelMap、Map的关系"></a>6、Model、ModelMap、Map的关系</h3><p>Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala">public interface <span class="hljs-type">Model</span>&#123;&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap&lt;String</span>, <span class="hljs-title">Object&gt;</span> </span>&#123;&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendedModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ModelMap</span> <span class="hljs-title">implements</span> <span class="hljs-title">Model</span> </span>&#123;&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BindingAwareModelMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExtendedModelMap</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="7、向session域共享数据"><a href="#7、向session域共享数据" class="headerlink" title="7、向session域共享数据"></a>7、向session域共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testSession&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testSession</span><span class="hljs-params">(HttpSession session)</span></span>&#123;<br>    session.setAttribute(<span class="hljs-string">&quot;testSessionScope&quot;</span>, <span class="hljs-string">&quot;hello,session&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、向application域共享数据"><a href="#8、向application域共享数据" class="headerlink" title="8、向application域共享数据"></a>8、向application域共享数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testApplication&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testApplication</span><span class="hljs-params">(HttpSession session)</span></span>&#123;<br>ServletContext application = session.getServletContext();<br>    application.setAttribute(<span class="hljs-string">&quot;testApplicationScope&quot;</span>, <span class="hljs-string">&quot;hello,application&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、SpringMVC的视图"><a href="#六、SpringMVC的视图" class="headerlink" title="六、SpringMVC的视图"></a>六、SpringMVC的视图</h1><p>SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户</p><p>SpringMVC视图的种类很多，默认有转发视图和重定向视图</p><p>当工程引入jstl的依赖，转发视图会自动转换为JstlView</p><p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p><h3 id="1、ThymeleafView"><a href="#1、ThymeleafView" class="headerlink" title="1、ThymeleafView"></a>1、ThymeleafView</h3><p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testHello&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://static01.imgkr.com/temp/330937f5dd9f4123a2002c507cb3703b.png" alt=""></p><h3 id="2、转发视图"><a href="#2、转发视图" class="headerlink" title="2、转发视图"></a>2、转发视图</h3><p>SpringMVC中默认的转发视图是InternalResourceView</p><p>SpringMVC中创建转发视图的情况：</p><p>当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转</p><p>例如”forward:/“，”forward:/employee”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testForward&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testForward</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/testHello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://static01.imgkr.com/temp/e15d3f72fed94c16b144a72e427f2d84.png" alt="image-20210706201316593"></p><h3 id="3、重定向视图"><a href="#3、重定向视图" class="headerlink" title="3、重定向视图"></a>3、重定向视图</h3><p>SpringMVC中默认的重定向视图是RedirectView</p><p>当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p><p>例如”redirect:/“，”redirect:/employee”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRedirect&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRedirect</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/testHello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://static01.imgkr.com/temp/79d4d9c002364fb1a567368981e2c638.png" alt="image-20210706201602267"></p><blockquote><p>注：</p><p>重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径</p></blockquote><h3 id="4、视图控制器view-controller"><a href="#4、视图控制器view-controller" class="headerlink" title="4、视图控制器view-controller"></a>4、视图控制器view-controller</h3><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">path：设置处理的请求地址</span><br><span class="hljs-comment">view-name：设置请求地址所对应的视图名称</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/testView&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;success&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-controller</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注：</p><p>当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：</p><mvc:annotation-driven /></blockquote><h1 id="七、RESTful"><a href="#七、RESTful" class="headerlink" title="七、RESTful"></a>七、RESTful</h1><h3 id="1、RESTful简介"><a href="#1、RESTful简介" class="headerlink" title="1、RESTful简介"></a>1、RESTful简介</h3><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。</p><h5 id="a-gt-资源"><a href="#a-gt-资源" class="headerlink" title="a&gt;资源"></a>a&gt;资源</h5><p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</p><h5 id="b-gt-资源的表述"><a href="#b-gt-资源的表述" class="headerlink" title="b&gt;资源的表述"></a>b&gt;资源的表述</h5><p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p><h5 id="c-gt-状态转移"><a href="#c-gt-状态转移" class="headerlink" title="c&gt;状态转移"></a>c&gt;状态转移</h5><p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p><h3 id="2、RESTful的实现"><a href="#2、RESTful的实现" class="headerlink" title="2、RESTful的实现"></a>2、RESTful的实现</h3><p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p><p>它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</p><p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p><div class="table-container"><table><thead><tr><th>操作</th><th>传统方式</th><th>REST风格</th></tr></thead><tbody><tr><td>查询操作</td><td>getUserById?id=1</td><td>user/1—&gt;get请求方式</td></tr><tr><td>保存操作</td><td>saveUser</td><td>user—&gt;post请求方式</td></tr><tr><td>删除操作</td><td>deleteUser?id=1</td><td>user/1—&gt;delete请求方式</td></tr><tr><td>更新操作</td><td>updateUser</td><td>user—&gt;put请求方式</td></tr></tbody></table></div><h3 id="3、HiddenHttpMethodFilter"><a href="#3、HiddenHttpMethodFilter" class="headerlink" title="3、HiddenHttpMethodFilter"></a>3、HiddenHttpMethodFilter</h3><p>由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？</p><p>SpringMVC 提供了 <strong>HiddenHttpMethodFilter</strong> 帮助我们<strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong></p><p><strong>HiddenHttpMethodFilter</strong> 处理put和delete请求的条件：</p><p>a&gt;当前请求的请求方式必须为post</p><p>b&gt;当前请求必须传输请求参数_method</p><p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式</p><p>在web.xml中注册<strong>HiddenHttpMethodFilter</strong> </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注：</p><p>目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter</p><p>在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter</p><p>原因：</p><ul><li><p>在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的</p></li><li><p>request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作</p></li><li><p>而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：</p></li><li><p>```<br>String paramValue = request.getParameter(this.methodParam);</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><br><br># 八、RESTful案例<br><br>### <span class="hljs-number">1</span>、准备工作<br><br>和传统 CRUD 一样，实现对员工信息的增删改查。<br><br>- 搭建环境<br><br>- 准备实体类<br>```java<br> package com.atguigu.mvc.bean;<br> <br> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> &#123;</span><br> <br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> lastName;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> email;<br>    <span class="hljs-comment">//1 male, 0 female</span><br>    <span class="hljs-keyword">private</span> Integer gender;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> id;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getLastName</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> lastName;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLastName</span><span class="hljs-params">(<span class="hljs-keyword">String</span> lastName)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.lastName = lastName;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getEmail</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> email;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmail</span><span class="hljs-params">(<span class="hljs-keyword">String</span> email)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.email = email;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getGender</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> gender;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGender</span><span class="hljs-params">(Integer gender)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.gender = gender;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(Integer id, <span class="hljs-keyword">String</span> lastName, <span class="hljs-keyword">String</span> email, Integer gender)</span> </span>&#123;<br>       <span class="hljs-built_in">super</span>();<br>       <span class="hljs-keyword">this</span>.id = id;<br>       <span class="hljs-keyword">this</span>.lastName = lastName;<br>       <span class="hljs-keyword">this</span>.email = email;<br>       <span class="hljs-keyword">this</span>.gender = gender;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li></ul></blockquote><ul><li>准备dao模拟数据<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mvc.dao;<br><br><span class="hljs-keyword">import</span> java.util.Collection;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">import</span> com.atguigu.mvc.bean.Employee;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeDao</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="hljs-keyword">null</span>;<br>   <br>   <span class="hljs-keyword">static</span>&#123;<br>      employees = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Employee&gt;();<br><br>      employees.put(<span class="hljs-number">1001</span>, <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">1001</span>, <span class="hljs-string">&quot;E-AA&quot;</span>, <span class="hljs-string">&quot;aa@163.com&quot;</span>, <span class="hljs-number">1</span>));<br>      employees.put(<span class="hljs-number">1002</span>, <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">1002</span>, <span class="hljs-string">&quot;E-BB&quot;</span>, <span class="hljs-string">&quot;bb@163.com&quot;</span>, <span class="hljs-number">1</span>));<br>      employees.put(<span class="hljs-number">1003</span>, <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">1003</span>, <span class="hljs-string">&quot;E-CC&quot;</span>, <span class="hljs-string">&quot;cc@163.com&quot;</span>, <span class="hljs-number">0</span>));<br>      employees.put(<span class="hljs-number">1004</span>, <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">1004</span>, <span class="hljs-string">&quot;E-DD&quot;</span>, <span class="hljs-string">&quot;dd@163.com&quot;</span>, <span class="hljs-number">0</span>));<br>      employees.put(<span class="hljs-number">1005</span>, <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">1005</span>, <span class="hljs-string">&quot;E-EE&quot;</span>, <span class="hljs-string">&quot;ee@163.com&quot;</span>, <span class="hljs-number">1</span>));<br>   &#125;<br>   <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer initId = <span class="hljs-number">1006</span>;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Employee employee)</span></span>&#123;<br>      <span class="hljs-keyword">if</span>(employee.getId() == <span class="hljs-keyword">null</span>)&#123;<br>         employee.setId(initId++);<br>      &#125;<br>      employees.put(employee.getId(), employee);<br>   &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;Employee&gt; <span class="hljs-title">getAll</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">return</span> employees.values();<br>   &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Employee <span class="hljs-title">get</span><span class="hljs-params">(Integer id)</span></span>&#123;<br>      <span class="hljs-keyword">return</span> employees.get(id);<br>   &#125;<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Integer id)</span></span>&#123;<br>      employees.remove(id);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2、功能清单"><a href="#2、功能清单" class="headerlink" title="2、功能清单"></a>2、功能清单</h3><div class="table-container"><table><thead><tr><th>功能</th><th>URL 地址</th><th>请求方式</th></tr></thead><tbody><tr><td>访问首页√</td><td>/</td><td>GET</td></tr><tr><td>查询全部数据√</td><td>/employee</td><td>GET</td></tr><tr><td>删除√</td><td>/employee/2</td><td>DELETE</td></tr><tr><td>跳转到添加数据页面√</td><td>/toAdd</td><td>GET</td></tr><tr><td>执行保存√</td><td>/employee</td><td>POST</td></tr><tr><td>跳转到更新数据页面√</td><td>/employee/2</td><td>GET</td></tr><tr><td>执行更新√</td><td>/employee</td><td>PUT</td></tr></tbody></table></div><h3 id="3、具体功能：访问首页"><a href="#3、具体功能：访问首页" class="headerlink" title="3、具体功能：访问首页"></a>3、具体功能：访问首页</h3><h5 id="a-gt-配置view-controller"><a href="#a-gt-配置view-controller" class="headerlink" title="a&gt;配置view-controller"></a>a&gt;配置view-controller</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;index&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h5 id="b-gt-创建页面"><a href="#b-gt-创建页面" class="headerlink" title="b&gt;创建页面"></a>b&gt;创建页面</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/employee&#125;&quot;</span>&gt;</span>访问员工信息<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4、具体功能：查询所有员工数据"><a href="#4、具体功能：查询所有员工数据" class="headerlink" title="4、具体功能：查询所有员工数据"></a>4、具体功能：查询所有员工数据</h3><h5 id="a-gt-控制器方法"><a href="#a-gt-控制器方法" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmployeeList</span><span class="hljs-params">(Model model)</span></span>&#123;<br>    Collection&lt;Employee&gt; employeeList = employeeDao.getAll();<br>    model.addAttribute(<span class="hljs-string">&quot;employeeList&quot;</span>, employeeList);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;employee_list&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="b-gt-创建employee-list-html"><a href="#b-gt-创建employee-list-html" class="headerlink" title="b&gt;创建employee_list.html"></a>b&gt;创建employee_list.html</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;en&quot;</span> xmlns:th=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;Employee Info&lt;/title&gt;<br>    &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>    &lt;table border=<span class="hljs-string">&quot;1&quot;</span> cellpadding=<span class="hljs-string">&quot;0&quot;</span> cellspacing=<span class="hljs-string">&quot;0&quot;</span> style=<span class="hljs-string">&quot;text-align: center;&quot;</span> id=<span class="hljs-string">&quot;dataTable&quot;</span>&gt;<br>        &lt;tr&gt;<br>            &lt;th colspan=&quot;5&quot;&gt;Employee Info&lt;/th&gt;<br>        &lt;/tr&gt;<br>        &lt;tr&gt;<br>            &lt;th&gt;id&lt;/th&gt;<br>            &lt;th&gt;lastName&lt;/th&gt;<br>            &lt;th&gt;email&lt;/th&gt;<br>            &lt;th&gt;gender&lt;/th&gt;<br>            &lt;th&gt;options(&lt;a th:href=&quot;@&#123;/toAdd&#125;&quot;&gt;add&lt;/a&gt;)&lt;/th&gt;<br>        &lt;/tr&gt;<br>        &lt;tr th:each=<span class="hljs-string">&quot;employee : $&#123;employeeList&#125;&quot;</span>&gt;<br>            &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt;<br>            &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt;<br>            &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt;<br>            &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt;<br>            &lt;td&gt;<br>                &lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt;<br>                &lt;a th:href=&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt;<br>            &lt;/td&gt;<br>        &lt;/tr&gt;<br>    &lt;/table&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h3 id="5、具体功能：删除"><a href="#5、具体功能：删除" class="headerlink" title="5、具体功能：删除"></a>5、具体功能：删除</h3><h5 id="a-gt-创建处理delete请求方式的表单"><a href="#a-gt-创建处理delete请求方式的表单" class="headerlink" title="a&gt;创建处理delete请求方式的表单"></a>a&gt;创建处理delete请求方式的表单</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;delete_form&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_method&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;delete&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="b-gt-删除超链接绑定点击事件"><a href="#b-gt-删除超链接绑定点击事件" class="headerlink" title="b&gt;删除超链接绑定点击事件"></a>b&gt;删除超链接绑定点击事件</h5><p>引入vue.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>删除超链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;deleteA&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;deleteEmployee&quot;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过vue处理点击事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> vue = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&quot;#dataTable&quot;</span>,</span><br>        methods:&#123;<br><span class="javascript">            <span class="hljs-comment">//event表示当前事件</span></span><br><span class="javascript">            deleteEmployee:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;</span><br><span class="javascript">                <span class="hljs-comment">//通过id获取表单标签</span></span><br><span class="javascript">                <span class="hljs-keyword">var</span> delete_form = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;delete_form&quot;</span>);</span><br><span class="javascript">                <span class="hljs-comment">//将触发事件的超链接的href属性为表单的action属性赋值</span></span><br>                delete_form.action = event.target.href;<br><span class="javascript">                <span class="hljs-comment">//提交表单</span></span><br>                delete_form.submit();<br><span class="javascript">                <span class="hljs-comment">//阻止超链接的默认跳转行为</span></span><br>                event.preventDefault();<br>            &#125;<br>        &#125;<br>    &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="c-gt-控制器方法"><a href="#c-gt-控制器方法" class="headerlink" title="c&gt;控制器方法"></a>c&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deleteEmployee</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;<br>    employeeDao.delete(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/employee&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6、具体功能：跳转到添加数据页面"><a href="#6、具体功能：跳转到添加数据页面" class="headerlink" title="6、具体功能：跳转到添加数据页面"></a>6、具体功能：跳转到添加数据页面</h3><h5 id="a-gt-配置view-controller-1"><a href="#a-gt-配置view-controller-1" class="headerlink" title="a&gt;配置view-controller"></a>a&gt;配置view-controller</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/toAdd&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;employee_add&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-controller</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="b-gt-创建employee-add-html"><a href="#b-gt-创建employee-add-html" class="headerlink" title="b&gt;创建employee_add.html"></a>b&gt;创建employee_add.html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Add Employee<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/employee&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    lastName:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastName&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    email:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    gender:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>male<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span>female<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7、具体功能：执行保存"><a href="#7、具体功能：执行保存" class="headerlink" title="7、具体功能：执行保存"></a>7、具体功能：执行保存</h3><h5 id="a-gt-控制器方法-1"><a href="#a-gt-控制器方法-1" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">addEmployee</span><span class="hljs-params">(Employee employee)</span></span>&#123;<br>    employeeDao.save(employee);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/employee&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8、具体功能：跳转到更新数据页面"><a href="#8、具体功能：跳转到更新数据页面" class="headerlink" title="8、具体功能：跳转到更新数据页面"></a>8、具体功能：跳转到更新数据页面</h3><h5 id="a-gt-修改超链接"><a href="#a-gt-修改超链接" class="headerlink" title="a&gt;修改超链接"></a>a&gt;修改超链接</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="b-gt-控制器方法"><a href="#b-gt-控制器方法" class="headerlink" title="b&gt;控制器方法"></a>b&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEmployeeById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id, Model model)</span></span>&#123;<br>    Employee employee = employeeDao.get(id);<br>    model.addAttribute(<span class="hljs-string">&quot;employee&quot;</span>, employee);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;employee_update&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="c-gt-创建employee-update-html"><a href="#c-gt-创建employee-update-html" class="headerlink" title="c&gt;创建employee_update.html"></a>c&gt;创建employee_update.html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Update Employee<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/employee&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;_method&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;put&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span><br>    lastName:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lastName&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    email:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        th:field=&quot;$&#123;employee.gender&#125;&quot;可用于单选框或复选框的回显</span><br><span class="hljs-comment">        若单选框的value和employee.gender的值一致，则添加checked=&quot;checked&quot;属性</span><br><span class="hljs-comment">    --&gt;</span><br>    gender:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">th:field</span>=<span class="hljs-string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>male<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">th:field</span>=<span class="hljs-string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>female<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="9、具体功能：执行更新"><a href="#9、具体功能：执行更新" class="headerlink" title="9、具体功能：执行更新"></a>9、具体功能：执行更新</h3><h5 id="a-gt-控制器方法-2"><a href="#a-gt-控制器方法-2" class="headerlink" title="a&gt;控制器方法"></a>a&gt;控制器方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">updateEmployee</span><span class="hljs-params">(Employee employee)</span></span>&#123;<br>    employeeDao.save(employee);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/employee&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机1</title>
    <link href="/2021/08/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA1/"/>
    <url>/2021/08/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工具2-Git</title>
    <link href="/2021/06/23/%E5%B7%A5%E5%85%B72-Git/"/>
    <url>/2021/06/23/%E5%B7%A5%E5%85%B72-Git/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工具1-maven</title>
    <link href="/2021/06/22/%E5%B7%A5%E5%85%B71-maven/"/>
    <url>/2021/06/22/%E5%B7%A5%E5%85%B71-maven/</url>
    
    <content type="html"><![CDATA[<h3 id="没有使用maven管理的项目">没有使用maven管理的项目</h3><ol type="1"><li><p>很多模块，模块之间有关系， 手工管理关系，比较繁琐。</p></li><li><p>需要很多第三方功能， 需要很多jar文件，需要手工从网络中获取各个jar</p></li><li><p>需要管理jar的版本， 你需要的是mysql.5.1.5.jar 拿你不能给给一个mysql.4.0.jar</p></li><li><p>管理jar文件之间的依赖， 你的项目要使用a.jar 需要使用b.jar里面的类。 必须首先获取到b.jar才可以， 然后才能使用a.jar.</p><p>（a.jar需要b.jar这个关系叫做依赖， 或者你的项目中要使用mysql的驱动， 也可以叫做项目依赖mysql驱动。 a.class使用b.class， a依赖b类）</p></li></ol><h3 id="需要改进项目的开发和管理需要maven"><strong>需要改进项目的开发和管理，需要maven</strong></h3><ol type="1"><li>maven可以管理jar文件</li><li>自动下载jar和他的文档，源代码</li><li>管理jar直接的依赖， a.jar需要b.jar ， maven会自动下载b.jar</li><li>管理你需要的jar版本</li><li>帮你编译程序，把java编译为class</li><li>帮你测试你的代码是否正确。</li><li>帮你打包文件，形成jar文件，或者war文件</li><li>帮你部署项目</li></ol><h3 id="构建-项目的构建"><strong>构建： 项目的构建</strong></h3><p>构建是面向过程的，就是一些步骤，完成项目代码的编译，测试，运行，打包，部署等等。 maven支持的构建包括有：</p><ol type="1"><li><p>清理， 把之前项目编译的东西删除掉，我新的编译代码做准备。</p></li><li><p>编译， 把程序源代码编译为执行代码， java-class文件</p><p>批量的，maven可以同时把成千上百的文件编译为class。</p><p>javac 不一样，javac一次编译一个文件。</p></li><li><p>测试， maven可以执行测试程序代码，验证你的功能是否正确。 批量的，maven同时执行多个测试代码，同时测试很多功能。</p></li><li><p>报告， 生成测试结果的文件， 测试通过没有。</p></li><li><p>打包， 把你的项目中所有的class文件，配置文件等所有资源放到一个压缩文件中。 这个压缩文件就是项目的结果文件， 通常java程序，压缩文件是jar扩展名的。 对于web应用，压缩文件扩展名是.war</p></li><li><p>安装， 把5中生成的文件jar，war安装到本机仓库</p></li><li><p>部署， 把程序安装好可以执行。</p></li></ol><h3 id="maven核心概念"><strong>maven核心概念</strong></h3><ol type="1"><li>POM ： 一个文件 名称是pom.xml , pom翻译过来叫做项目对象模型。 maven把一个项目当做一个模型使用。控制maven构建项目的过程，管理jar依赖。</li><li>约定的目录结构 ： maven项目的目录和文件的位置都是规定的。</li><li>坐标 ： 是一个唯一的字符串，用来表示资源的。</li><li>依赖管理 ： 管理你的项目可以使用jar文件</li><li>仓库管理（了解） ：你的资源存放的位置</li><li>生命周期 (了解) ： maven工具构建项目的过程，就是生命周期。</li><li>插件和目标（了解）：执行maven构建的时候用的工具是插件</li><li>继承</li><li>聚合</li></ol><p>讲maven的使用，先难后易的。 难是说使用maven的命令，完成maven使用 ， 在idea中直接使用maven，代替命令。</p><h3 id="maven约定的目录结构">maven约定的目录结构</h3><ol type="1"><li><p>约定是大家都遵循的一个规则。</p><p>每一个maven项目在磁盘中都是一个文件夹（项目-Hello） Hello/ —/src ------/main #放你主程序java代码和配置文件 ----------/java #你的程序包和包中的java文件 ----------/resources #你的java程序中要使用的配置文件 ------/test #放测试程序代码和文件的（可以没有） ----------/java #测试程序包和包中的java文件 ----------/resources #测试java程序中要使用的配置文件 —/pom.xml #maven的核心文件（maven项目必须有）</p></li><li><p>疑问： mvn compile 编译src/main目录下的所有java文件的。</p><ol type="1"><li><p>为什么要下载 maven工具执行的操作需要很多插件（java类–jar文件）完成的</p></li><li><p>下载什么东西了 jar文件–叫做插件–插件是完成某些功能</p></li><li><p>下载的东西存放到哪里了。 默认仓库（本机仓库）： C:（登录操作系统的用户名）Administrator.m2</p><p>Downloading: https://repo.maven.apache.org/maven2/org/apache/maven/maven-plugin-parameter-documenter-2.0.9.pom https://repo.maven.apache.org ：中央仓库的地址</p></li><li><p>执行mvn compile， 结果是在项目的根目录下生成target目录（结果目录）， maven编译的java程序，最后的class文件都放在target目录中</p>设置本机存放资源的目录位置(设置本机仓库)：<ol type="1"><li><p>修改maven的配置文件， maven安装目录/conf/settings.xml 先备份 settings.xml</p></li><li><p>修改 <localRepository> 指定你的目录（不要使用中文目录）</p></li></ol><p>D:_work_repository</p></li></ol></li></ol><h3 id="仓库">仓库</h3><ol type="1"><li>仓库是什么： 仓库是存放东西的， 存放maven使用的jar 和 我们项目使用的jar</li></ol><blockquote><p>maven使用的插件（各种jar） 我项目使用的jar(第三方的工具)</p></blockquote><ol start="2" type="1"><li>仓库的分类</li></ol><blockquote><p>本地仓库， 就是你的个人计算机上的文件夹，存放各种jar 远程仓库， 在互联网上的，使用网络才能使用的仓库 ①：中央仓库，最权威的， 所有的开发人员都共享使用的一个集中的仓库， https://repo.maven.apache.org ：中央仓库的地址 ②：中央仓库的镜像：就是中央仓库的备份， 在各大洲，重要的城市都是镜像。 ③：私服，在公司内部，在局域网中使用的， 不是对外使用的。</p></blockquote><ol start="3" type="1"><li><p>仓库的使用，maven仓库的使用不需要人为参与。 开发人员需要使用mysql驱动---&gt;maven首先查本地仓库---&gt;私服---&gt;镜像---&gt;中央仓库</p></li><li><p>pom:项目对象模型，是一个pom.xml文件</p><ol type="1"><li><p>坐标：唯一值， 在互联网中唯一标识一个项目的 公司域名的倒写 groupId 自定义项目名称 ArtifactId 自定版本号 Version</p><p>https://mvnrepository.com/ 搜索使用的中央仓库， 使用groupId 或者 artifactId作为搜索条件</p></li><li><p>packaging： 打包后压缩文件的扩展名，默认是jar ，web应用是war packaging 可以不写， 默认是jar</p></li><li><p>依赖 dependencies 和dependency ，相当于是 java代码中import</p><p>你的项目中要使用的各种资源说明， 比我的项目要使用mysql驱动</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--依赖  java代码中 import --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>properties：设置属性</li><li>build ： maven在进行项目的构建时， 配置信息，例如指定编译java代码使用的jdk的版本等</li></ol></li></ol></li></ol><h3 id="maven生命周期">Maven生命周期</h3><p>maven生命周期， maven的命令，maven的插件 maven的生命周期：就是maven构建项目的过程，清理，编译，测试，报告，打包，安装，部署 maven的命令：maven独立使用，通过命令，完成maven的生命周期的执行。 maven可以使用命令，完成项目的清理，编译，测试等等 maven的插件： maven命令执行时，真正完成功能的是插件，插件就是一些jar文件， 一些类。</p><ol type="1"><li><p>单元测试（测试方法）：用的是junit， junit是一个专门测试的框架（工具）。 junit测试的内容： 测试的是类中的方法， 每一个方法都是独立测试的。 方法是测试的基本单位（单元）。</p><p>maven借助单元测试，批量的测试你类中的大量方法是否符合预期的。</p></li><li><p>使用步骤</p><ol type="1"><li><p>加入依赖，在pom.xml加入单元测试依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在maven项目中的src/test/java目录下，创建测试程序。</p><p>推荐的创建类和方法的提示：</p><ol type="1"><li><p>测试类的名称 是Test + 你要测试的类名</p></li><li><p>测试的方法名称 是：Test + 方法名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如你要测试HelloMaven ,</span></span><br><span class="line"><span class="comment">//创建测试类 TestHelloMaven</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">     测试HelloMaven的add方法是否正确</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>其中testAdd叫做测试方法，它的定义规则:</p><ol type="1"><li><p>方法是public的，必须的</p></li><li><p>方法没有返回值， 必须的</p></li><li><p>方法名称是自定义的，推荐是Test + 方法名称</p></li><li><p>在方法的上面加入 <span class="citation" data-cites="Test">@Test</span></p></li></ol></li></ol></li><li><p>mvn compile 编译main/java/目录下的java 为class文件， 同时把class拷贝到 target/classes目录下面 把main/resources目录下的所有文件 都拷贝到target/classes目录下</p></li></ol></li></ol><h3 id="idea中应用">IDEA中应用</h3><ol type="1"><li><p>在idea中设置maven ，让idea和maven结合使用。 idea中内置了maven ，一般不使用内置的， 因为用内置修改maven的设置不方便。 使用自己安装的maven， 需要覆盖idea中的默认的设置。让idea指定maven安装位置等信息</p></li><li><p>配置的入口 ①：配置当前工程的设置， file--settings ---Build, Excution,Deployment--Build Tools --Maven Maven Home directory: maven的安装目录 User Settings File : 就是maven安装目录conf/setting.xml配置文件 Local Repository : 本机仓库的目录位置</p><pre><code>                --Build Tools--Maven--Runner                     VM Options : -DarchetypeCatalog=internal                   JRE: 你项目的jdk            -DarchetypeCatalog=internal , maven项目创建时，会联网下载模版文件，               比较大， 使用-DarchetypeCatalog=internal，不用下载， 创建maven项目速度快。（2019版本以后，新的就不用添加这个）       配置以后新建工程的设置， other settings--Settings for New Project</code></pre></li></ol><p>3.使用模版创建项目 1）maven-archetype-quickstart : 普通的java项目 2）maven-archetype-webapp : web工程</p><h3 id="依赖范围">依赖范围</h3><p>依赖范围， 使用scope表示</p><p>scope的值有 compile, test, provided ,默认是compile scope:表示依赖使用的范围，也就是在maven构建项目的那些阶段中起作用。 maven构建项目 编译， 测试 ，打包， 安装 ，部署 过程（阶段）</p><p>compile依赖范围是从编译一直到部署，junit的依赖范围是 test。provided依赖范围到测试为止，不参与打包和部署（可能该包在打包安装部署时由其他方提供）</p><p>你在写项目的中的用到的所有依赖（jar ） ，必须在本地仓库中有。 没有必须通过maven下载， 包括provided的都必须下载。</p><p>你在servlet需要继承HttpServlet( provided) , 你使用的HttpServlet是maven仓库中的。 当你的写好的程序， 放到 tomat服务器中运行时， 此时你的程序中不包含servlet的jar 因为tomcat提供了 servlet的.jar</p><h3 id="maven常用操作">Maven常用操作</h3><ol type="1"><li><p>maven的属性设置 <properties> 设置maven的常用属性</p></li><li><p>maven的全局变量 自定义的属性，1. 在<properties> 通过自定义标签声明变量（标签名就是变量名） 2. 在pom.xml文件中的其它位置，使用 ${标签名} 使用变量的值</p></li></ol><p>自定义全局变量一般是定义 依赖的版本号， 当你的项目中要使用多个相同的版本号， 先使用全局变量定义， 在使用${变量名}</p><ol start="3" type="1"><li>资源插件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span><span class="comment">&lt;!--所在的目录--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">includes</span>&gt;</span><span class="comment">&lt;!--包括目录下的.properties,.xml 文件都会扫描到--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--filtering 选项 false 不启用过滤器， *.property 已经起到过滤的作用了 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java-SpringMVC</title>
    <link href="/2021/06/22/Java-SpringMVC1-%E4%BB%8B%E7%BB%8D%E3%80%81demo%E3%80%81Mapping%E6%B3%A8%E8%A7%A3%E5%8F%8A%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/06/22/Java-SpringMVC1-%E4%BB%8B%E7%BB%8D%E3%80%81demo%E3%80%81Mapping%E6%B3%A8%E8%A7%A3%E5%8F%8A%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、SpringMVC简介"><a href="#一、SpringMVC简介" class="headerlink" title="一、SpringMVC简介"></a>一、SpringMVC简介</h1><h3 id="1、什么是MVC"><a href="#1、什么是MVC" class="headerlink" title="1、什么是MVC"></a>1、什么是MVC</h3><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li><li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li></ul><p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p><p>MVC的工作流程：<br>用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器</p><h3 id="2、什么是SpringMVC"><a href="#2、什么是SpringMVC" class="headerlink" title="2、什么是SpringMVC"></a>2、什么是SpringMVC</h3><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目</p><p>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的<strong>首选方案</strong>。</p><blockquote><p>注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet</p></blockquote><h3 id="3、SpringMVC的特点"><a href="#3、SpringMVC的特点" class="headerlink" title="3、SpringMVC的特点"></a>3、SpringMVC的特点</h3><ul><li><strong>Spring 家族原生产品</strong>，与 IOC 容器等基础设施无缝对接</li><li><strong>基于原生的Servlet</strong>，通过了功能强大的<strong>前端控制器DispatcherServlet</strong>，对请求和响应进行统一处理</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li><li><strong>代码清新简洁</strong>，大幅度提升开发效率</li><li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li><li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li></ul><h1 id="二、HelloWorld"><a href="#二、HelloWorld" class="headerlink" title="二、HelloWorld"></a>二、HelloWorld</h1><h3 id="1、开发环境"><a href="#1、开发环境" class="headerlink" title="1、开发环境"></a>1、开发环境</h3><p>IDE：idea 2019.2</p><p>构建工具：maven3.5.4</p><p>服务器：tomcat7</p><p>Spring版本：5.3.1</p><h3 id="2、创建maven工程"><a href="#2、创建maven工程" class="headerlink" title="2、创建maven工程"></a>2、创建maven工程</h3><h5 id="a-gt-添加web模块"><a href="#a-gt-添加web模块" class="headerlink" title="a&gt;添加web模块"></a>a&gt;添加web模块</h5><h5 id="b-gt-打包方式：war"><a href="#b-gt-打包方式：war" class="headerlink" title="b&gt;打包方式：war"></a>b&gt;打包方式：war</h5><h5 id="c-gt-引入依赖"><a href="#c-gt-引入依赖" class="headerlink" title="c&gt;引入依赖"></a>c&gt;引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- SpringMVC --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 日志 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- ServletAPI --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- Spring5和Thymeleaf整合包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。</p><p><img src="https://static01.imgkr.com/temp/41f4905c5a164eb1946f10be7e45ab93.png" alt="images"></p><h3 id="3、配置web-xml"><a href="#3、配置web-xml" class="headerlink" title="3、配置web.xml"></a>3、配置web.xml</h3><p>注册SpringMVC的前端控制器DispatcherServlet</p><h5 id="a-gt-默认配置方式"><a href="#a-gt-默认配置方式" class="headerlink" title="a&gt;默认配置方式"></a>a&gt;默认配置方式</h5><p>此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为\<servlet-name>-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span><br><span class="hljs-comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span><br><span class="hljs-comment">        但是/不能匹配.jsp请求路径的请求</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="b-gt-扩展配置方式"><a href="#b-gt-扩展配置方式" class="headerlink" title="b&gt;扩展配置方式"></a>b&gt;扩展配置方式</h5><p>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment"> 作为框架的核心组件，在启动过程中有大量的初始化操作要做</span><br><span class="hljs-comment">而这些操作放在第一次请求时才执行会严重影响访问速度</span><br><span class="hljs-comment">因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span><br><span class="hljs-comment">--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span><br><span class="hljs-comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span><br><span class="hljs-comment">        但是/不能匹配.jsp请求路径的请求</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注：</p><p>\<url-pattern>标签中使用/和/*的区别：</p><p>/所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求</p><p>因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面</p><p>/<em>则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/\</em>的写法</p></blockquote><h3 id="4、创建请求控制器"><a href="#4、创建请求控制器" class="headerlink" title="4、创建请求控制器"></a>4、创建请求控制器</h3><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器</p><p>请求控制器中每一个处理请求的方法成为控制器方法</p><p>因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、创建springMVC的配置文件"><a href="#5、创建springMVC的配置文件" class="headerlink" title="5、创建springMVC的配置文件"></a>5、创建springMVC的配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 自动扫描包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.atguigu.mvc.controller&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;viewResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateEngine&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateResolver&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span><br>    <br>                    <span class="hljs-comment">&lt;!-- 视图前缀 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span><br>    <br>                    <span class="hljs-comment">&lt;!-- 视图后缀 --&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.html&quot;</span>/&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;templateMode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;HTML5&quot;</span>/&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;characterEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">   处理静态资源，例如html、js、css、jpg</span><br><span class="hljs-comment">  若只设置该标签，则只能访问静态资源，其他请求则无法访问</span><br><span class="hljs-comment">  此时必须设置&lt;mvc:annotation-driven/&gt;解决问题</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 开启mvc注解驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultCharset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;supportedMediaTypes&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>text/html<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>application/json<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6、测试HelloWorld"><a href="#6、测试HelloWorld" class="headerlink" title="6、测试HelloWorld"></a>6、测试HelloWorld</h3><h5 id="a-gt-实现对首页的访问"><a href="#a-gt-实现对首页的访问" class="headerlink" title="a&gt;实现对首页的访问"></a>a&gt;实现对首页的访问</h5><p>在请求控制器中创建处理请求的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @RequestMapping注解：处理请求和控制器方法之间的映射关系</span><br><span class="hljs-comment">// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径</span><br><span class="hljs-comment">// localhost:8080/springMVC/</span><br><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//设置视图名称</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="b-gt-通过超链接跳转到指定页面"><a href="#b-gt-通过超链接跳转到指定页面" class="headerlink" title="b&gt;通过超链接跳转到指定页面"></a>b&gt;通过超链接跳转到指定页面</h5><p>在主页index.html中设置超链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/hello&#125;&quot;</span>&gt;</span>HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在请求控制器中创建处理请求的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">HelloWorld</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;target&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h3><p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面</p><h1 id="三、-RequestMapping注解"><a href="#三、-RequestMapping注解" class="headerlink" title="三、@RequestMapping注解"></a>三、@RequestMapping注解</h1><h3 id="1、-RequestMapping注解的功能"><a href="#1、-RequestMapping注解的功能" class="headerlink" title="1、@RequestMapping注解的功能"></a>1、@RequestMapping注解的功能</h3><p>从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p><h3 id="2、-RequestMapping注解的位置"><a href="#2、-RequestMapping注解的位置" class="headerlink" title="2、@RequestMapping注解的位置"></a>2、@RequestMapping注解的位置</h3><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p><p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestMappingController</span> </span>&#123;<br><br><span class="hljs-comment">//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRequestMapping</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、-RequestMapping注解的value属性"><a href="#3、-RequestMapping注解的value属性" class="headerlink" title="3、@RequestMapping注解的value属性"></a>3、@RequestMapping注解的value属性</h3><p>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射</p><p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p><p>@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/testRequestMapping&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/testRequestMapping<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(</span><br><span class="hljs-meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRequestMapping</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、-RequestMapping注解的method属性"><a href="#4、-RequestMapping注解的method属性" class="headerlink" title="4、@RequestMapping注解的method属性"></a>4、@RequestMapping注解的method属性</h3><p>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射</p><p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求</p><p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/test&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(</span><br><span class="hljs-meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;,</span><br><span class="hljs-meta">        method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRequestMapping</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><p>1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p><p>处理get请求的映射—&gt;@GetMapping</p><p>处理post请求的映射—&gt;@PostMapping</p><p>处理put请求的映射—&gt;@PutMapping</p><p>处理delete请求的映射—&gt;@DeleteMapping</p><p>2、常用的请求方式有get，post，put，delete</p><p>但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理</p><p>若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到</p></blockquote><h3 id="5、-RequestMapping注解的params属性（了解）"><a href="#5、-RequestMapping注解的params属性（了解）" class="headerlink" title="5、@RequestMapping注解的params属性（了解）"></a>5、@RequestMapping注解的params属性（了解）</h3><p>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射</p><p>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p><p>“param”：要求请求映射所匹配的请求必须携带param请求参数</p><p>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</p><p>“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value</p><p>“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/test(username=&#x27;admin&#x27;,password=123456)&quot;</span>&gt;</span>测试@RequestMapping的params属性--&gt;/test<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(</span><br><span class="hljs-meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span><br><span class="hljs-meta">        ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span><br><span class="hljs-meta">        ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRequestMapping</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456}</p></blockquote><h3 id="6、-RequestMapping注解的headers属性（了解）"><a href="#6、-RequestMapping注解的headers属性（了解）" class="headerlink" title="6、@RequestMapping注解的headers属性（了解）"></a>6、@RequestMapping注解的headers属性（了解）</h3><p>@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射</p><p>@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系</p><p>“header”：要求请求映射所匹配的请求必须携带header请求头信息</p><p>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息</p><p>“header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value</p><p>“header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value</p><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到</p><h3 id="7、SpringMVC支持ant风格的路径"><a href="#7、SpringMVC支持ant风格的路径" class="headerlink" title="7、SpringMVC支持ant风格的路径"></a>7、SpringMVC支持ant风格的路径</h3><p>？：表示任意的单个字符</p><p>*：表示任意的0个或多个字符</p><p>**：表示任意的一层或多层目录</p><p>注意：在使用*<em>时，只能使用/*</em>/xxx的方式</p><h3 id="8、SpringMVC支持路径中的占位符（重点）"><a href="#8、SpringMVC支持路径中的占位符（重点）" class="headerlink" title="8、SpringMVC支持路径中的占位符（重点）"></a>8、SpringMVC支持路径中的占位符（重点）</h3><p>原始方式：/deleteUser?id=1</p><p>rest方式：/deleteUser/1</p><p>SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/testRest/1/admin&#125;&quot;</span>&gt;</span>测试路径中的占位符--&gt;/testRest<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRest</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> String id, <span class="hljs-meta">@PathVariable(&quot;username&quot;)</span> String username)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;id:&quot;</span>+id+<span class="hljs-string">&quot;,username:&quot;</span>+username);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br><span class="hljs-comment">//最终输出的内容为--&gt;id:1,username:admin</span><br></code></pre></td></tr></table></figure><h1 id="四、SpringMVC获取请求参数"><a href="#四、SpringMVC获取请求参数" class="headerlink" title="四、SpringMVC获取请求参数"></a>四、SpringMVC获取请求参数</h1><h3 id="1、通过ServletAPI获取"><a href="#1、通过ServletAPI获取" class="headerlink" title="1、通过ServletAPI获取"></a>1、通过ServletAPI获取</h3><p>将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testParam&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testParam</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>    String username = request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>    String password = request.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;username:&quot;</span>+username+<span class="hljs-string">&quot;,password:&quot;</span>+password);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、通过控制器方法的形参获取请求参数"><a href="#2、通过控制器方法的形参获取请求参数" class="headerlink" title="2、通过控制器方法的形参获取请求参数"></a>2、通过控制器方法的形参获取请求参数</h3><p>在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;</span>&gt;</span>测试获取请求参数--&gt;/testParam<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testParam&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testParam</span><span class="hljs-params">(String username, String password)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;username:&quot;</span>+username+<span class="hljs-string">&quot;,password:&quot;</span>+password);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：</p><p>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数</p><p>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</p><p>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</p></blockquote><h3 id="3、-RequestParam"><a href="#3、-RequestParam" class="headerlink" title="3、@RequestParam"></a>3、@RequestParam</h3><p>@RequestParam是将请求参数和控制器方法的形参创建映射关系</p><p>@RequestParam注解一共有三个属性：</p><p>value：指定为形参赋值的请求参数的参数名</p><p>required：设置是否必须传输此请求参数，默认值为true</p><p>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null</p><p>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</p><h3 id="4、-RequestHeader"><a href="#4、-RequestHeader" class="headerlink" title="4、@RequestHeader"></a>4、@RequestHeader</h3><p>@RequestHeader是将请求头信息和控制器方法的形参创建映射关系</p><p>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><h3 id="5、-CookieValue"><a href="#5、-CookieValue" class="headerlink" title="5、@CookieValue"></a>5、@CookieValue</h3><p>@CookieValue是将cookie数据和控制器方法的形参创建映射关系</p><p>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><h3 id="6、通过POJO获取请求参数"><a href="#6、通过POJO获取请求参数" class="headerlink" title="6、通过POJO获取请求参数"></a>6、通过POJO获取请求参数</h3><p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/testpojo&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    性别：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;男&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    邮箱：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/testpojo&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testPOJO</span><span class="hljs-params">(User user)</span></span>&#123;<br>    System.out.println(user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br><span class="hljs-comment">//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="7、解决获取请求参数的乱码问题"><a href="#7、解决获取请求参数的乱码问题" class="headerlink" title="7、解决获取请求参数的乱码问题"></a>7、解决获取请求参数的乱码问题</h3><p>解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置springMVC的编码过滤器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceResponseEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>注：</p><p>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法刷题小结1</title>
    <link href="/2021/06/19/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%B0%8F%E7%BB%931/"/>
    <url>/2021/06/19/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%B0%8F%E7%BB%931/</url>
    
    <content type="html"><![CDATA[<h3 id="边界测试用例">边界测试用例</h3><p>被各种边界测试用例干碎了，写个小节记录一下</p><ol type="1"><li><p>整形的Long，Integer，Short，Byte都可以用各自类的MAX_VALUE和MIN_VALUE使用各自类型所允许的最大和最小值；</p></li><li><p>浮点型的Double和Float与整形不同，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> MAX_VALUE = <span class="number">0x1.fffffffffffffP+1023</span>; <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> MIN_NORMAL = <span class="number">0x1.0p-1022</span>; <span class="comment">// 2.2250738585072014E-308</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> MIN_VALUE = <span class="number">0x0.0000000000001P-1022</span>; <span class="comment">// 4.9e-324</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> POSITIVE_INFINITY = <span class="number">1.0</span> / <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NEGATIVE_INFINITY = -<span class="number">1.0</span> / <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NaN = <span class="number">0.0d</span> / <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><p>其MAX_VALUE为最大正数，MIN_VALUE为最小正数，Double表示范围的左边界可由</p><p>-MAX_VALUE表示。</p><p>（一般尽量不要强行用Double强转来补Int类型的边界用例问题，很浪费）</p></li></ol><h3 id="char类型和int类型转换">Char类型和Int类型转换</h3><ol type="1"><li><p>注意char类型的0~9数字强转int并不等于真实数字</p><p>’0‘对应char的十进制为48，'A'为65，'a'为97</p></li><li><p>真不行用Integer.decode(String str)直接将string转码成int，可接受八、十、十六进制</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java-Spring5框架2-AOP</title>
    <link href="/2021/06/15/Java-Spring5%E6%A1%86%E6%9E%B62-AOP/"/>
    <url>/2021/06/15/Java-Spring5%E6%A1%86%E6%9E%B62-AOP/</url>
    
    <content type="html"><![CDATA[<h3 id="aop">AOP</h3><ol type="1"><li>什么是 AOP<ol type="1"><li>面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</li><li>通俗描述：不通过修改源代码方式，在主干功能里面添加新功能</li></ol></li><li><p>AOP底层原理</p><ul><li><p>AOP底层使用动态代理（分两种情况）</p></li><li><p>有接口情况下使用JDK动态代理，创建接口实现类代理对象，增强类的方法</p></li><li><p>没有接口情况，使用CGLIB动态代理，创建子类的代理对象，增强类的方法</p><figure><img src="https://i.loli.net/2021/06/15/PXiOvbohgtKJQZG.png" alt="AOP底层两种情况.png" /><figcaption>AOP底层两种情况.png</figcaption></figure></li></ul></li><li><p>AOP（JDK 动态代理）</p><ol type="1"><li><p>使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象</p><p>java.lang.reflect Class Proxy</p><ul><li><p>调用newProxyInstance方法</p><p>方法有三个参数： 第一参数，类加载器 第二参数，增强方法所在的类，这个类实现的接口，支持多个接口 第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分</p></li></ul></li><li><p>编写JDK动态代理代码</p><ol type="1"><li><p>创建接口，定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建接口实现类，实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Proxy 类创建接口代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line">        UserDaoImpl userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">        UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(),</span><br><span class="line">                interfaces,<span class="keyword">new</span> UserDaoProxy(userDao));</span><br><span class="line">        <span class="keyword">int</span> res = dao.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建代理对象代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="comment">//把被代理对象传递过来</span></span><br><span class="line">    <span class="comment">//有参数构造传递</span></span><br><span class="line">    Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserDaoProxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增强的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//方法之前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName()+<span class="string">&quot; :传递的参数...&quot;</span>+ Arrays.toString(objects));</span><br><span class="line">        <span class="comment">//被增强的方法执行</span></span><br><span class="line">        Object res = method.invoke(obj, objects);</span><br><span class="line">        <span class="comment">//方法之后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>+obj);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="aop术语">AOP术语</h3><ol type="1"><li>连接点：类中哪些方法可以被增强，这些方法称为连接点</li><li>切入点：实际被真正增强的方法，称为切入点</li><li>通知（增强）：<ol type="1"><li>实际增强的逻辑部分称为通知（增强）</li><li>通知有多种类型<ul><li>前置通知</li><li>后置通知</li><li>环绕通知</li><li>异常通知</li><li>最终通知</li></ul></li></ol></li><li>切面：是动作，把通知应用到切入点的过程</li></ol><h3 id="aop操作准备工作">AOP操作（准备工作）</h3><ol type="1"><li><p>Spring 框架一般都是基于 AspectJ 实现 AOP 操作</p><p>AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使 用，进行 AOP 操作。</p></li><li><p>基于 AspectJ 实现 AOP 操作</p><ol type="1"><li>基于 xml 配置文件实现</li><li>基于注解方式实现（使用）</li></ol></li><li><p>在项目工程里面引入 AOP 相关依赖</p></li><li><p>切入点表达式</p><ol type="1"><li>切入点表达式作用：知道对哪个类里面的哪个方法进行增强</li><li>语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]) )</li></ol></li></ol><p>举例 1：对 com.crazya1ice.dao.BookDao 类里面的 add 进行增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.crazya1ice.dao.BookDao.add(..))</span><br></pre></td></tr></table></figure><p>举例 2：对 com.crazya1ice.dao.BookDao 类里面的所有的方法进行增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.crazya1ice.dao.BookDao.* (..))</span><br></pre></td></tr></table></figure><p>举例 3：对 com.crazya1ice.dao包里面所有类，类里面所有方法进行增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com.crazya1ice.dao.*.* (..))</span><br></pre></td></tr></table></figure><h3 id="aop-操作aspectj-注解">AOP 操作（AspectJ 注解）</h3><ol type="1"><li><p>创建类，在类里面定义方法</p></li><li><p>创建增强类（编写增强逻辑） 增强类里面，创建方法，让不同方法代表不同通知类型</p></li><li><p>进行通知的配置</p><ol type="1"><li><p>在 spring 配置文件中，开启注解扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.crazya1ice&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用注解创建原对象和增强类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//此注解用于创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Original</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adding=====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OriginalProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在增强类上面添加注解 <span class="citation" data-cites="Aspect">@Aspect</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//此注解作用是把当前类标识为一个切面供容器读取</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OriginalProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 spring 配置文件中开启生成代理对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启 Aspect 生成代理对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>配置不同类型的通知</p><p>在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OriginalProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前置通知 在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常。</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.crazya1ice.springstudy.aopanno.Original.add(..)&quot;)</span></span><br><span class="line"><span class="meta">    public void before()&#123;</span></span><br><span class="line"><span class="meta">        System.out.println(&quot;before====&quot;);</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">    //后置通知  无论程序是否发生异常都会执行的</span></span><br><span class="line"><span class="meta">    @After(value = &quot;execution(* com.crazya1ice.springstudy.aopanno.Original.add(..)&quot;)</span></span><br><span class="line"><span class="meta">    public void after()&#123;</span></span><br><span class="line"><span class="meta">        System.out.println(&quot;after====&quot;);</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">    //环绕通知 围绕在连接点前后</span></span><br><span class="line"><span class="meta">    @Around(value = &quot;execution(* com.crazya1ice.springstudy.aopanno.Original.add(..)&quot;)</span></span><br><span class="line"><span class="meta">    public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123;</span></span><br><span class="line"><span class="meta">        System.out.println(&quot;before-around====&quot;);</span></span><br><span class="line"><span class="meta">        proceedingJoinPoint.proceed();//被增强方法的执行</span></span><br><span class="line"><span class="meta">        System.out.println(&quot;after-around====&quot;);</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">    //异常通知 连接点抛出异常后执行</span></span><br><span class="line"><span class="meta">    @AfterThrowing(value = &quot;execution(* com.crazya1ice.springstudy.aopanno.Original.add(..)&quot;)</span></span><br><span class="line"><span class="meta">    public void afterThrowing()&#123;</span></span><br><span class="line"><span class="meta">        System.out.println(&quot;afterThrowing====&quot;);</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">    //返回通知 方法调用后正常返回的时候通知，可以获取返回值，发生异常的时候不会执行</span></span><br><span class="line"><span class="meta">    @AfterReturning(value = &quot;execution(* com.crazya1ice.springstudy.aopanno.Original.add(..)&quot;)</span></span><br><span class="line"><span class="meta">    public void afterReturning()&#123;</span></span><br><span class="line"><span class="meta">        System.out.println(&quot;afterTReturning====&quot;);</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>相同的切入点抽取</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(value = &quot;execution(* com.crazya1ice.springstudy.aopanno.Original.add(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="meta">@Before(value = &quot;pointcut()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before====&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6" type="1"><li><p>有多个增强类多同一个方法进行增强，设置增强类优先级</p><p>在增强类上面添加注解 <span class="citation" data-cites="Order">@Order</span>(数字类型值)，数字类型值越小优先级越高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OriginalProxy</span></span></span><br></pre></td></tr></table></figure></li><li><p>完全使用注解开发</p></li></ol></li></ol><h4 id="aop操作by配置文件了解">AOP操作by配置文件（了解）</h4><ol type="1"><li><p>创建增强类和被增强类以及方法</p></li><li><p>在spring配置文件中用bean标签创建两个类对象</p></li><li><p>在spring配置文件中配置切入点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.crazya1ice.springstudy.aopanno.Original.add(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;originalProxy&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置增强作用的具体方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java Spring5框架1-IOC容器</title>
    <link href="/2021/06/07/Java-Spring5%E6%A1%86%E6%9E%B61-IOC%E5%AE%B9%E5%99%A8/"/>
    <url>/2021/06/07/Java-Spring5%E6%A1%86%E6%9E%B61-IOC%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="spring框架概述">Spring框架概述</h3><ul><li>Spring框架是轻量级的开源JavaEE框架。</li><li>Spring框架可以解决企业应用开发的复杂性。</li><li>Spring中有两个核心部分：IOC和Aop。<ul><li>IOC：控制反转，把创建对象过程交给Spring进行管理</li><li>Aop：面向切面，不修改源代码进行功能增强</li></ul></li><li>特点：<ul><li>方便解耦，简化开发；（IOC）</li><li>Aop编程支持；</li><li>方便程序的测试；</li><li>方便集成各种优秀框架；</li><li>封装JavaEE api，降低开发难度；</li><li>方便进行事务处理；</li><li>Spring源码经典。</li></ul></li><li>当前学习Spring5.x</li></ul><h3 id="入门案例">入门案例</h3><ol type="1"><li><p>下载：spring.io</p></li><li><p>新建Java项目并导入必需的jar包</p><ol type="1"><li>Beans</li><li>Core</li><li>Context</li><li>Expression</li><li>Commons-logging日志包</li></ol></li><li><p>创建普通类和方法</p></li><li><p>Spring中创建对象可以通过配置文件或注解来进行</p><p>创建Spring配置文件，在配置文件中配置创建的对象</p><p>Spring配置文件使用xml格式，可使用<bean>来创建对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试创建对象</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//加载 Spring配置文件</span></span><br><span class="line">    ApplicationContext applicationContext =</span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//创建配置文件中配置的对象</span></span><br><span class="line">    User user = applicationContext.getBean(<span class="string">&quot;user&quot;</span>,User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    user.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ioc容器">IOC容器</h3><p>IOC底层原理</p><p>Inversion of Control，控制反转</p><ul><li>把对象的创建和对象之间调用的过程，都交给Spring进行管理</li><li>使用IOC目的，为了耦合度降低</li><li>入门案例中就有IOC实现</li></ul><p>底层原理：</p><ul><li>xml解析，工厂模式，反射</li></ul><p>画图讲解：</p><p><img src="https://static01.imgkr.com/temp/1521a64b8a304a57885f388ef94b78c7.png" /></p><p>IOC接口（BeanFactory）</p><ul><li><p>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p></li><li><p>Spring提供IOC容器实现的两种方式（两个接口）</p><ul><li><p>BeanFactory：IOC容器的基本实现，是Spring内部使用的接口，不提供给开发人员使用</p><p>*加载配置文件时不会创建对象，在获取/使用时才去创建对象</p></li><li><p>ApplicationContext：BeanFactory接口的子接口，提供了更多更强大的功能，一般由开发人员使用</p><p>*加载配置文件时就会创建对象</p></li></ul></li><li><p>ApplicationContext接口有实现类</p></li></ul><p><img src="https://static01.imgkr.com/temp/5d398ab911044969ac2fe07ce91a2c38.png" /></p><p>FileSystemXmlApplicationContext类使用盘符路径作为初始化参数</p><p>ClassSystemXmlApplicationContext类使用类下的路径作为初始化参数</p><p>IOC 操作 Bean 管理（概念）</p><ol type="1"><li>Bean 管理指的是两个操作：<ol type="1"><li>Spring创建对象</li><li>Spring注入属性</li></ol></li><li>Bean管理操作有两种方式：<ol type="1"><li>基于xml配置文件方式实现</li><li>基于注解方式实现</li></ol></li></ol><p>IOC 操作 Bean 管理（基于xml方式）</p><ol type="1"><li><p>基于xml方式创建对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建</li><li>在 bean 标签有很多属性，介绍常用的属性<ul><li>id 属性：唯一标识</li><li>class 属性：类全路径（包类路径）</li></ul></li><li>创建对象时候，默认也是执行无参数构造方法完成对象创建</li></ul></li><li><p>基于xml方式注入属性</p><p>DI：依赖注入，就是注入属性</p></li><li><p>第一种注入方式：使用set方法进行注入</p><ol type="1"><li>创建类，定义属性和对应的 set 方法（默认执行无参数构造方法创建对象）</li><li>在 spring 配置文件配置对象创建，配置属性注入</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用 property 完成属性注入</span></span><br><span class="line"><span class="comment">        name：类里面属性名称</span></span><br><span class="line"><span class="comment">        value：向属性注入的值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Alice&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二种注入方式：使用有参数构造进行注入</p><ol type="1"><li>创建类，定义属性，创建属性对应有参数构造方法</li><li>在 spring 配置文件中进行配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Alice&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>p 名称空间注入（了解）</p><p>使用 p 名称空间注入，可以简化基于 xml 配置方式</p><ol type="1"><li><p>第一步 添加 p 名称空间在配置文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二步 进行属性注入，在 bean 标签里面进行操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;Alice&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><p>IOC 操作 Bean 管理（xml注入其他类型属性）</p><ol type="1"><li><p>字面量</p><ol type="1"><li><p>null值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>属性值包含特殊符号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--属性值包含特殊符号</span></span><br><span class="line"><span class="comment">1 把&lt;&gt;进行转义 &amp;lt; &amp;gt;</span></span><br><span class="line"><span class="comment">2 把带特殊符号内容写到 CDATA</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;中国&gt;&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>注入属性-外部 bean</p><ol type="1"><li>创建两个类 service 类和 dao 类</li><li>在 service 调用 dao 里面的方法</li><li>在 spring 配置文件中进行配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.UserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入 userDao 对象</span></span><br><span class="line"><span class="comment">    name 属性：类里面属性名称</span></span><br><span class="line"><span class="comment">    ref 属性：创建 userDao 对象 bean 标签 id 值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userDao.Update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注入属性-内部bean和级联赋值</p><ol type="1"><li><p>内部bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span> = <span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;技术部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>级联赋值</p><ul><li>方法一：同注入外部bean，在外部bean中给属性赋值</li><li>方法二：用.属性的方式在property标签内赋值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;组织部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span> = <span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;技术部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><p>IOC 操作 Bean 管理（xml 注入集合属性）</p><ol type="1"><li>注入数组类型属性</li><li>注入 List 集合类型属性</li><li>注入 Map 集合类型属性</li></ol><p>步骤：</p><ul><li>创建类，定义数组、list、map、set 类型属性，生成对应 set 方法</li><li>在 spring 配置文件进行配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 集合类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Stu&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--数组类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courses&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>java 课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据库课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--list 类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>小三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--map 类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;JAVA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;PHP&quot;</span> <span class="attr">value</span>=<span class="string">&quot;php&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--set 类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>MySQL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Redis<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4" type="1"><li><p>在集合里面设置对象类型值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建多个 course 对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring5 框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Course&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MyBatis 框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入 list 集合类型，值是对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>把集合注入部分提取出来</p><ol type="1"><li><p>在 spring 配置文件中引入名称空间 util</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/util</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 util 标签完成 list 集合注入提取</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1 提取 list 集合类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>易筋经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>九阴真经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>九阳神功<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2 提取 list 集合类型属性注入使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.collectiontype.Book&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><p>IOC 操作 Bean 管理（FactoryBean）</p><ol type="1"><li>Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）</li><li>普通 bean：在配置文件中定义 bean 类型就是返回类型</li><li>工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样<ol type="1"><li>第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean</li><li>第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Emp</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//定义返回 bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Emp emp = <span class="keyword">new</span> Emp();</span><br><span class="line">        emp.setName(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> emp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.bean.MyBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">    Emp emp  = context.getBean(<span class="string">&quot;myBean&quot;</span>,Emp.class);</span><br><span class="line">    System.out.println(emp.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IOC 操作 Bean 管理（bean 作用域）</p><ol type="1"><li>在 Spring 里面，设置创建 bean 实例是单实例还是多实例</li><li>在 Spring 里面，默认情况下，bean 是单实例对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dept dept1 = context.getBean(<span class="string">&quot;dept&quot;</span>, Dept.class);</span><br><span class="line">Dept dept2 = context.getBean(<span class="string">&quot;dept&quot;</span>, Dept.class);</span><br><span class="line">System.out.println(dept1);</span><br><span class="line">System.out.println(dept2);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;地址相同</span><br><span class="line">com.crazya1ice.springstudy.bean.Dept@18bf3d14</span><br><span class="line">com.crazya1ice.springstudy.bean.Dept@18bf3d14</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li><p>如何设置单实例还是多实例</p><ol type="1"><li><p>在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例</p></li><li><p>scope 属性值</p><p>第一个值 默认值，singleton，表示是单实例对象 第二个值 prototype，表示是多实例对象</p></li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.bean.Dept&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;某部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--多例，此时各对象地址不同--&gt;</span></span><br></pre></td></tr></table></figure><pre><code>        3. singleton 和 prototype 区别</code></pre><ul><li>第一 singleton 单实例，prototype 多实例</li><li>第二 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象，设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用getBean 方法时候创建多实例对象</li></ul><p>IOC 操作 Bean 管理（bean 生命周期）</p><ol type="1"><li><p>生命周期：从对象创建到对象销毁的过程</p></li><li><p>bean 生命周期：</p><ol type="1"><li>通过构造器创建 bean 实例（无参数构造）</li><li>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</li><li>调用 bean 的初始化的方法（需要进行配置初始化的方法）</li><li>bean 可以使用了（对象获取到了）</li><li>当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</li></ol></li><li><p>演示 bean 生命周期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orders</span> </span>&#123;</span><br><span class="line">    <span class="comment">//无参数构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Orders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一步 执行无参数构造创建 bean 实例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String oname;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOname</span><span class="params">(String oname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.oname = oname;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二步 调用 set 方法设置属性值&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建执行的初始化的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第三步 执行初始化的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建执行的销毁的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第五步 执行销毁的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.bean.Orders&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;手机&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBean3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context =</span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line">    Orders orders = context.getBean(<span class="string">&quot;orders&quot;</span>, Orders.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;第四步 获取创建 bean 实例对象&quot;</span>);</span><br><span class="line">    System.out.println(orders);</span><br><span class="line">    <span class="comment">//手动让 bean 实例销毁</span></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li><p>bean 的后置处理器，bean 生命周期实际上有七步</p><ol type="1"><li>通过构造器创建 bean 实例（无参数构造）</li><li>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</li><li>把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization</li><li>调用 bean 的初始化的方法（需要进行配置初始化的方法）</li><li>把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization</li><li>bean 可以使用了（对象获取到了）</li><li>当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</li></ol></li><li><p>演示添加后置处理器效果</p><p>创建类，实现接口 BeanPostProcessor，创建后置处理器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.bean.MyBeanPost&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPost</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果如下</span></span><br><span class="line"><span class="comment">/**第一步 执行无参数构造创建 bean 实例</span></span><br><span class="line"><span class="comment">第二步 调用 set 方法设置属性值</span></span><br><span class="line"><span class="comment">在初始化之前执行的方法</span></span><br><span class="line"><span class="comment">第三步 执行初始化的方法</span></span><br><span class="line"><span class="comment">在初始化之后执行的方法</span></span><br><span class="line"><span class="comment">第四步 获取创建 bean 实例对象</span></span><br><span class="line"><span class="comment">com.crazya1ice.springstudy.bean.Orders@25bbf683</span></span><br><span class="line"><span class="comment">第五步 执行销毁的方法**/</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><p>IOC 操作 Bean 管理（xml 自动装配）</p><ol type="1"><li><p>什么是自动装配：根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入</p></li><li><p>演示自动装配过程</p><ol type="1"><li><p>根据属性名称自动注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--实现自动装配</span></span><br><span class="line"><span class="comment">    bean 标签属性 autowire，配置自动装配</span></span><br><span class="line"><span class="comment">    autowire 属性常用两个值：</span></span><br><span class="line"><span class="comment">    byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样</span></span><br><span class="line"><span class="comment">    byType 根据属性类型注入</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.bean.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.bean.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据属性类型自动注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.crazya1ice.springstudy.bean.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><p>IOC 操作 Bean 管理(外部属性文件)</p><ol type="1"><li><p>直接配置数据库信息</p><ol type="1"><li><p>配置德鲁伊连接池</p></li><li><p>引入德鲁伊连接池依赖 jar 包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--直接配置连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/bookstore&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>引入外部属性文件配置数据库连接池</p><ol type="1"><li><p>创建外部属性文件，properties 格式文件，写数据库信息</p></li><li>把外部 properties 属性文件引入到 spring 配置文件中<ul><li><p>引入 context 名称空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span><br></pre></td></tr></table></figure></li><li><p>在 spring 配置文件使用标签引入外部属性文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入外部属性文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClass&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><p>IOC 操作 Bean 管理(基于注解方式)</p><ol type="1"><li><p>什么是注解</p><ol type="1"><li>注解是代码特殊标记，格式：<span class="citation" data-cites="注解名称">@注解名称</span>(属性名称=属性值, 属性名称=属性值..)</li><li>使用注解，注解作用在类上面，方法上面，属性上面</li><li>使用注解目的：简化 xml 配置</li></ol></li><li><p>Spring 针对 Bean 管理中创建对象提供注解</p><ol type="1"><li><p><span class="citation" data-cites="Component">@Component</span></p></li><li><p><span class="citation" data-cites="Service">@Service</span></p></li><li><p><span class="citation" data-cites="Controller">@Controller</span></p></li><li><p><span class="citation" data-cites="Repository">@Repository</span></p><p>上面四个注解功能是一样的，都可以用来创建 bean 实例</p></li></ol></li><li><p>基于注解方式实现对象创建</p><ol type="1"><li><p>第一步 引入依赖</p><p>spring-aop-5.3.7.jar</p></li><li><p>第二步 开启组件扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启组件扫描</span></span><br><span class="line"><span class="comment">    1 如果扫描多个包，多个包使用逗号隔开</span></span><br><span class="line"><span class="comment">    2 扫描包上层目录</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.crazya1ice&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第三步 创建类，在类上面添加创建对象注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在注解里面 value 属性值可以省略不写，</span></span><br><span class="line"><span class="comment">//默认值是类名称，首字母小写</span></span><br><span class="line"><span class="comment">//UserService -- userService</span></span><br><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adding====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启组件扫描细节配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例 1</span></span><br><span class="line"><span class="comment">use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filter</span></span><br><span class="line"><span class="comment">context:include-filter ，设置扫描哪些内容</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.crazya1ice&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--示例 2</span></span><br><span class="line"><span class="comment">下面配置扫描包所有内容</span></span><br><span class="line"><span class="comment">context:exclude-filter： 设置哪些内容不进行扫描</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.crazya1ice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基于注解方式实现属性注入</p><ol type="1"><li><p><span class="citation" data-cites="Autowired">@Autowired</span>：根据属性类型进行自动装配 第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解 第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上使用注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义 dao 类型属性</span></span><br><span class="line">    <span class="comment">//不需要添加 set 方法</span></span><br><span class="line">    <span class="comment">//添加注入属性注解</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line">        userDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><span class="citation" data-cites="Qualifier">@Qualifier</span>：根据名称进行注入 这个@Qualifier 注解的使用，和上面@Autowired 一起使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="comment">//根据类型进行注入</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;userDaoImpl1&quot;)</span> <span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure></li><li><p><span class="citation" data-cites="Resource">@Resource</span>：可以根据类型注入，可以根据名称注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span> <span class="comment">//根据类型进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(name = &quot;userDaoImpl1&quot;)</span> <span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure></li><li><p><span class="citation" data-cites="Value">@Value</span>：注入普通类型属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>完全注解开发</p><ol type="1"><li><p>创建配置类，替代 xml 配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//作为配置类，替代 xml 配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.crazya1ice&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testService2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//加载配置类</span></span><br><span class="line">    ApplicationContext context</span><br><span class="line">            = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">    UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>,</span><br><span class="line">            UserService.class);</span><br><span class="line">    System.out.println(userService);</span><br><span class="line">    userService.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java Spring 5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb学习-简单项目</title>
    <link href="/2021/06/03/JavaWeb%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/06/03/JavaWeb%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="javaee项目的三层架构">JavaEE项目的三层架构</h3><p><img src="https://static01.imgkr.com/temp/d39dee0f9d924db3a2907bbe712a9b2e.png" /></p><p>分层的目的是为了解耦。解耦就是为了降低代码的耦合度。方便项目后期的维护和升级。</p><ul><li><p>web层 com.crazya1ice.web/servlet/controller</p></li><li><p>service层 com.crazya1ice.service Service接口包</p><p>​ com.crazya1ice.service.impl Service接口实现类</p></li><li><p>dao持久层 com.crazya1ice.dao Dao接口包</p><p>​ com.crazya1ice.dao.impl Dao接口实现类</p></li><li><p>实体bean对象 com.crazya1ice.pojo/entity/domain/bean JavaBeanl类</p></li><li><p>测试包 com.crazya1ice.test/junit</p></li><li><p>工具类 com.crazya1ice.utils</p></li></ul><h4 id="步骤">步骤</h4><ol type="1"><li><p>先创建书城需要的数据库和表；</p></li><li><p>编写数据库表对应的JavaBean对象；</p></li><li><p>编写工具类JdbcUtils；</p><ol type="1"><li>导入jar包</li><li>编写jdbc.properties；</li><li>编写JdbcUtils工具类；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DruidDataSource dataSource;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">/* 读取 jdbc.properties 属性配置文件 */</span></span><br><span class="line">            InputStream inputStream =</span><br><span class="line">                    JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">            <span class="comment">// 从流中加载数据</span></span><br><span class="line">            properties.load(inputStream);</span><br><span class="line">            <span class="comment">// 创建 数据库连接 池</span></span><br><span class="line">            dataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">            System.out.println(dataSource.getConnection());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据库连接池中的连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回 null,说明获取连接失败&lt;br/&gt;有值就是获取连接成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = dataSource.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">        <span class="comment">//return null;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭连接，放回数据库连接池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>JdbcUtils测试；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJdbcUtils</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        Connection connection = JdbcUtils.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        JdbcUtils.close(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写 BaseDao</p><ol type="1"><li>导入 DBUtils 的 jar 包</li><li>编写BaseDao</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用 DbUtils 操作数据库</span></span><br><span class="line">    <span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * update() 方法用来执行：Insert\Update\Delete 语句</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回-1,说明执行失败&lt;br/&gt;返回其他表示影响的行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String sql, Object... args)</span> </span>&#123;</span><br><span class="line">        Connection connection = JdbcUtils.getConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queryRunner.update(connection, sql, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.close(connection);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询返回一个 javaBean 的 sql 语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 返回的对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">    执行的 sql 语句</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args sql 对应的参数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">    返回的类型的泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">queryForOne</span><span class="params">(Class&lt;T&gt; type, String sql, Object... args)</span> </span>&#123;</span><br><span class="line">        Connection con = JdbcUtils.getConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queryRunner.query(con, sql, <span class="keyword">new</span> BeanHandler&lt;T&gt;(type), args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.close(con);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询返回多个 javaBean 的 sql 语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 返回的对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">    执行的 sql 语句</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args sql 对应的参数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">    返回的类型的泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">queryForList</span><span class="params">(Class&lt;T&gt; type, String sql, Object... args)</span> </span>&#123;</span><br><span class="line">        Connection con = JdbcUtils.getConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queryRunner.query(con, sql, <span class="keyword">new</span> BeanListHandler&lt;T&gt;(type), args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.close(con);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行返回一行一列的 sql 语句</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">    执行的 sql 语句</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">    sql 对应的参数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">queryForSingleValue</span><span class="params">(String sql, Object... args)</span></span>&#123;</span><br><span class="line">        Connection conn = JdbcUtils.getConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queryRunner.query(conn, sql, <span class="keyword">new</span> ScalarHandler(), args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.close(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写UserDao和测试</p><p>UserDao接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名查询用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回 null,说明没有这个用户。反之亦然</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 用户名和密码查询用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回 null,说明用户名或密码错误,反之亦然</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserByUsernameAndPassword</span><span class="params">(String username,String password)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回-1 表示操作失败，其他是 sql 语句影响的行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserDaoImpl 实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select `id`,`username`,`password`,`email` from user where username = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> queryForOne(User.class, sql, username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserByUsernameAndPassword</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select `id`,`username`,`password`,`email` from user where username = ? and password = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> queryForOne(User.class, sql, username,password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;insert into user(`username`,`password`,`email`) values(?,?,?)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> update(sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserDao 测试：</p><p>Shif+Ctrl+t 快速生成测试</p></li><li><p>编写 UserService 和测试</p><ol type="1"><li><p>UserService 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回 null，说明登录失败，返回有值，是登录成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查 用户名是否可用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 true 表示用户名已存在，返回 false 表示用户名可用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">existsUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserServiceImpl 实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userDao.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.queryUserByUsernameAndPassword(user.getUsername(), user.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">existsUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.queryUserByUsername(username)!=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserService 测试：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    userService.registUser(<span class="keyword">new</span> User(<span class="keyword">null</span>,<span class="string">&quot;miamia&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="string">&quot;123456@miamia.com&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    System.out.println(userService.login(<span class="keyword">new</span> User(<span class="keyword">null</span>, <span class="string">&quot;miamia&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;123456@miamia.com&quot;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">existsUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    <span class="keyword">if</span>(userService.existsUsername(<span class="string">&quot;miamia&quot;</span>))</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名已存在&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户名可使用&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Web层</p><ol type="1"><li><p>注册逻辑</p><p><img src="https://static01.imgkr.com/temp/092be9d5118c47b5b7a644c480edf08c.png" /></p></li><li><p>修改html页面</p><ol type="1"><li>添加base标签</li><li>修改base标签对页面中相对路径的影响</li><li>修改注册表单的提交地址和请求方式</li></ol></li><li><p>编写RegistServlet程序</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1、获取请求的参数</span></span><br><span class="line">    String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    String password = request.getParameter(<span class="string">&quot;repwd&quot;</span>);</span><br><span class="line">    String email = request.getParameter(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    String code = request.getParameter(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="comment">//2、检查 验证码是否正确</span></span><br><span class="line">    <span class="comment">//=== 写死,要求验证码为:abcde</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;abcde&quot;</span>.equalsIgnoreCase(code))&#123;</span><br><span class="line">        <span class="keyword">if</span>(userService.existsUsername(username))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名已存在&quot;</span>);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/pages/user/regist.html&quot;</span>).forward(request,response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            userService.registUser(<span class="keyword">new</span> User(<span class="keyword">null</span>,username,password,email));</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/pages/user/regist_success.html&quot;</span>).forward(request,response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/pages/user/regist.html&quot;</span>).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>用户登录类似</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb学习-Servlet</title>
    <link href="/2021/05/31/JavaWeb%E5%AD%A6%E4%B9%A0-Servlet/"/>
    <url>/2021/05/31/JavaWeb%E5%AD%A6%E4%B9%A0-Servlet/</url>
    
    <content type="html"><![CDATA[<h3 id="servlet">1.Servlet</h3><ol type="1"><li>Servlet 是 JavaEE 规范之一。规范就是接口</li><li>Servlet 就 JavaWeb 三大组件之一。三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监听器。</li><li>Servlet 是运行在服务器上的一个 java 小程序，它可以接收客户端发送过来的请求，并响应数据给客户端。</li></ol><h4 id="手动实现servlet程序">手动实现Servlet程序</h4><ol type="1"><li>编写一个类去实现 Servlet 接口</li><li>实现 service 方法，处理请求，并响应数据</li><li>到 web.xml 中去配置 servlet 程序的访问地址</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet 标签给 Tomcat 配置 Servlet 程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet-name 标签 Servlet 程序起一个别名（一般是类名） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet-class 是 Servlet 程序的全类名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.JavaWebTomcat.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet-mapping 标签给 servlet 程序配置访问地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个 Servlet 程序使用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        url-pattern 标签配置访问地址 &lt;br/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        / 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        /hello 表示地址为：http://ip:port/工程路径/hello--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="servlet生命周期">Servlet生命周期</h4><ol type="1"><li>执行 Servlet 构造器方法</li><li>执行 init 初始化方法 第一、二步，是在第一次访问，的时候创建 Servlet 程序会调用。</li><li>执行 service 方法 第三步，每次访问都会调用。</li><li>执行 destroy 销毁方法 第四步，在 web 工程停止的时候调用。</li></ol><h4 id="通过继承-httpservlet-实现-servlet-程序">通过继承 HttpServlet 实现 Servlet 程序</h4><p>一般在实际项目开发中，都是使用继承 HttpServlet 类的方式去实现 Servlet 程序。</p><ol type="1"><li>编写一个类去继承 HttpServlet 类</li><li>根据业务需要重写 doGet 或 doPost 方法</li><li>到 web.xml 中的配置 Servlet 程序的访问地址</li></ol><h4 id="servlet类的继承体系">Servlet类的继承体系</h4><p><img src="https://static01.imgkr.com/temp/7884330c9521477fb4229e7b09d58394.png" /></p><h3 id="servletconfig类">2. ServletConfig类</h3><ul><li>ServletConfig 类从类名上来看，就知道是 Servlet 程序的配置信息类。</li><li>Servlet 程序和 ServletConfig 对象都是由 Tomcat 负责创建，我们负责使用。</li><li>Servlet 程序默认是第一次访问的时候创建，ServletConfig 是每个 Servlet 程序创建时，就创建一个对应的 ServletConfig 对象。</li></ul><h4 id="servletconfig-类的三大作用">ServletConfig 类的三大作用：</h4><ul><li>可以获取 Servlet 程序的别名 servlet-name 的值</li><li>获取初始化参数 init-param</li><li>获取 ServletContext 对象</li></ul><p>web.xml 中的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet 标签给 Tomcat 配置 Servlet 程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet-name 标签 Servlet 程序起一个别名（一般是类名） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet-class 是 Servlet 程序的全类名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.example.JavaWebTomcat.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--init-param 是初始化参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是参数名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是参数值--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--init-param 是初始化参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是参数名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>url<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是参数值--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet-mapping 标签给 servlet 程序配置访问地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个 Servlet 程序使用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        url-pattern 标签配置访问地址</span></span><br><span class="line"><span class="comment">        &lt;br/&gt;</span></span><br><span class="line"><span class="comment">        / 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径</span></span><br><span class="line"><span class="comment">        &lt;br/&gt;</span></span><br><span class="line"><span class="comment">        /hello 表示地址为：http://ip:port/工程路径/hello</span></span><br><span class="line"><span class="comment">        &lt;br/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Servlet中的代码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.init(config);<span class="comment">//重写init时需调用父类此方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2 init 初始化方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、可以获取 Servlet 程序的别名 servlet-name 的值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;HelloServlet 程序的别名是:&quot;</span> + servletConfig.getServletName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取初始化参数 init-param</span></span><br><span class="line">    System.out.println(<span class="string">&quot;初始化参数 username 的值是;&quot;</span> +            servletConfig.getInitParameter(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;初始化参数 url 的值是;&quot;</span> + servletConfig.getInitParameter(<span class="string">&quot;url&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、获取 ServletContext 对象</span></span><br><span class="line">    System.out.println(servletConfig.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="servletcontext对象">3. ServletContext对象</h3><ul><li><p>ServletContext 是一个接口，它表示 Servlet 上下文对象</p></li><li><p>一个 web 工程，只有一个 ServletContext 对象实例。</p></li><li><p>ServletContext 对象是一个域对象。</p></li><li><p>ServletContext 是在 web 工程部署启动的时候创建。在 web 工程停止的时候销毁。</p><p>域对象，是可以像 Map 一样存取数据的对象，叫域对象。 这里的域指的是存取数据的操作范围，整个 web 工程。</p><p>存数据 取数据 删除数据</p><p>put() get() remove() Map</p><p>setAttribute() getAttribute() removeAttribute() 域对象</p></li></ul><h4 id="作用">作用</h4><ol type="1"><li>获取 web.xml 中配置的上下文参数 context-param</li><li>获取当前的工程路径，格式: /工程路径</li><li>获取工程部署后在服务器硬盘上的绝对路径</li><li>像 Map 一样存取数据</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--context-param 是上下文参数(它属于整个 web 工程)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>context<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--context-param 是上下文参数(它属于整个 web 工程)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>password<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1、获取 web.xml 中配置的上下文参数 context-param</span></span><br><span class="line">    ServletContext context = getServletConfig().getServletContext();</span><br><span class="line">    String username = context.getInitParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;context-param 参数 username 的值是:&quot;</span> + username);</span><br><span class="line">    System.out.println(<span class="string">&quot;context-param 参数 password 的值是:&quot;</span> +</span><br><span class="line">            context.getInitParameter(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">    <span class="comment">//2、获取当前的工程路径，格式: /工程路径</span></span><br><span class="line">    System.out.println( <span class="string">&quot;当前工程路径:&quot;</span> + context.getContextPath() );</span><br><span class="line">    <span class="comment">//3、获取工程部署后在服务器硬盘上的绝对路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 斜杠被服务器解析地址为:http://ip:port/工程名/</span></span><br><span class="line"><span class="comment">    映射到 IDEA 代码的 webapp 目录&lt;br/&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;工程部署的路径是:&quot;</span> + context.getRealPath(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;工程下 css 目录的绝对路径是:&quot;</span> + context.getRealPath(<span class="string">&quot;/css&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;工程下 imgs 目录 1.jpg 的绝对路径是:&quot;</span> + context.getRealPath(<span class="string">&quot;/imgs/1.jpg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="http协议">4. HTTP协议</h3><p>HTTP 协议：客户端和服务器之间通信时，发送的数据，需要遵守的规则 HTTP 协议中的数据又叫报文。</p><ul><li>客户端给服务器发送数据叫请求。</li><li>服务器给客户端回传数据叫响应。</li><li>请求又分为 GET 请求，和 POST 请求两种</li></ul><h4 id="get请求">GET请求</h4><ol type="1"><li><p>请求行</p><ol type="1"><li>请求的方式 GET</li><li>请求的资源路径[+?+请求参数]</li><li>请求的协议的版本号 HTTP/1.1</li></ol></li><li><p>请求头</p><p>​ key:value 不同的键值对，表示不同的含义</p></li></ol><p><img src="https://static01.imgkr.com/temp/6438a77faa2d431a8446d953581f30d1.png" /></p><h4 id="post请求">POST请求</h4><ol type="1"><li><p>请求行</p><ol type="1"><li>请求的方式 POST</li><li>请求的资源路径[+?+请求参数]</li><li>请求的协议的版本号 HTTP/1.1</li></ol></li><li><p>请求头</p><p>​ key:value 不同的键值对，表示不同的含义</p><p><font color = "red">空行</font></p></li><li><p>请求体：发送给服务器的数据</p></li></ol><p><img src="https://static01.imgkr.com/temp/b03bdaa08817497d8ad49bb775772313.png" /></p><h4 id="常用请求头的说明">常用请求头的说明</h4><ul><li>Accept:表示客户端可以接收的数据类型</li><li>Accpet-Languege: 表示客户端可以接收的语言类型</li><li>User-Agent:表示客户端浏览器的信息</li><li>Host： 表示请求时的服务器 ip 和端口号</li></ul><h4 id="哪些是-get-请求哪些是-post-请求">哪些是 GET 请求，哪些是 POST 请求</h4><p>GET 请求有哪些：</p><ul><li>form 标签 method=get</li><li>a 标签</li><li>link 标签引入 css</li><li>Script 标签引入 js 文件</li><li>img 标签引入图片</li><li>iframe 引入 html 页面</li><li>在浏览器地址栏中输入地址后敲回车</li></ul><p>POST 请求有哪些：</p><ul><li>form 标签 method=post</li></ul><h4 id="响应的-http-协议格式">响应的 HTTP 协议格式</h4><ol type="1"><li><p>响应行</p><ol type="1"><li>响应的协议和版本号</li><li>响应状态码</li><li>响应状态描述符</li></ol></li><li>响应头<ol type="1"><li>key:value 不同的键值对，表示不同的含义</li></ol><p><font color = "red">空行</font></p></li><li><p>响应体：回传给客户端的数据</p></li></ol><p><img src="https://static01.imgkr.com/temp/4fb8752c8fcf47a4ad0fde938a41bfa4.png" /></p><p>响应码说明：</p><ul><li>200 请求成功</li><li>302 请求重定向</li><li>404 请求服务器已经收到了，但是你要的数据不存在（请求地址错误）</li><li>500 服务器已经收到请求，但是服务器内部错误（代码错误）</li></ul><h4 id="mime-类型说明">MIME 类型说明</h4><p>MIME 是 HTTP 协议中数据类型。</p><p>MIME 的英文全称是&quot;Multipurpose Internet Mail Extensions&quot; 多功能 Internet 邮件扩充服务。</p><p>MIME 类型的格式是“大类型/小类型”，并与某一种文件的扩展名相对应。</p><h3 id="httpservletrequest-类">5. HttpServletRequest 类</h3><p>作用：每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中。 然后传递到 service 方法（doGet 和 doPost）中给我们使用。我们可以通过 HttpServletRequest 对象，获取到所有请求的信息。</p><h4 id="httpservletrequest-类的常用方法">HttpServletRequest 类的常用方法</h4><ul><li>getRequestURI() 获取请求的资源路径</li><li>getRequestURL() 获取请求的统一资源定位符（绝对路径）</li><li>getRemoteHost() 获取客户端的 ip 地址</li><li>getHeader() 获取请求头</li><li>getParameter() 获取请求的参数</li><li>getParameterValues() 获取请求的参数（多个值的时候使用）</li><li>getMethod() 获取请求的方式 GET 或 POST</li><li>setAttribute(key, value); 设置域数据</li><li>getAttribute(key); 获取域数据</li><li>getRequestDispatcher() 获取请求转发对象</li><li>setCharacterEncoding() 设置请求体的字符集，可用于解决doPost中乱码问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//i.getRequestURI()获取请求的资源路径</span></span><br><span class="line">    System.out.println(<span class="string">&quot;URI =&gt; &quot;</span> + request.getRequestURI());</span><br><span class="line">    <span class="comment">//ii.getRequestURL()获取请求的统一资源定位符（绝对路径）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;URL =&gt; &quot;</span> + request.getRequestURL());</span><br><span class="line">    <span class="comment">//iii.getRemoteHost()获取客户端的 ip 地址</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在 IDEA 中，使用 localhost 访问时，得到的客户端 ip 地址是 ===&gt;&gt;&gt; 127.0.0.1&lt;br/&gt;</span></span><br><span class="line"><span class="comment">    * 在 IDEA 中，使用 127.0.0.1 访问时，得到的客户端 ip 地址是 ===&gt;&gt;&gt; 127.0.0.1&lt;br/&gt;</span></span><br><span class="line"><span class="comment">    * 在 IDEA 中，使用 真实 ip 访问时，得到的客户端 ip 地址是 ===&gt;&gt;&gt; 真实的客户端 ip 地址&lt;br/&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;客户端 ip 地址 =&gt; &quot;</span> + request.getRemoteHost());</span><br><span class="line">    <span class="comment">//iv.getHeader()获取请求头</span></span><br><span class="line">    System.out.println(<span class="string">&quot;请求头 User-Agent ==&gt;&gt; &quot;</span> + request.getHeader(<span class="string">&quot;User-Agent&quot;</span>));</span><br><span class="line">    <span class="comment">//vii.getMethod()获取请求的方式 GET 或 POST</span></span><br><span class="line">    System.out.println( <span class="string">&quot;请求的方式 ==&gt;&gt; &quot;</span> + request.getMethod() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何获取请求参数">如何获取请求参数</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080/phpstudy/contextservlet&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        爱好：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span> = <span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cpp&quot;</span>&gt;</span>C艹</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span> = <span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span> = <span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;js&quot;</span>&gt;</span>Javascript</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    String[] hobbies = request.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">    <span class="comment">//1 先以 iso8859-1 进行编码，</span></span><br><span class="line"><span class="comment">//2 再以 utf-8 进行解码，解决doGet中中文乱码问题</span></span><br><span class="line">    username = <span class="keyword">new</span> String(username.getBytes(<span class="string">&quot;iso-8859-1&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;用户名：&quot;</span>+username);</span><br><span class="line">    System.out.println(<span class="string">&quot;密码：&quot;</span>+password);</span><br><span class="line">    System.out.println(<span class="string">&quot;兴趣爱好：&quot;</span>+Arrays.asList(hobbies));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="请求的转发">请求的转发</h4><p>请求转发是指，服务器收到请求后，从一个资源跳转到另一个资源的操作叫请求转发。</p><p><img src="https://static01.imgkr.com/temp/59c493e6a492449dac76c45b374640b8.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Servlet1代码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求的参数（办事的材料）查看</span></span><br><span class="line">    String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;在 Servlet1（柜台 1）中查看参数（材料）：&quot;</span> + username);</span><br><span class="line">    <span class="comment">// 给材料 盖一个章，并传递到 Servlet2（柜台 2）去查看</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;柜台 1 的章&quot;</span>);</span><br><span class="line">    <span class="comment">// 问路：Servlet2（柜台 2）怎么走</span></span><br><span class="line">    <span class="comment">// 请求转发必须要以斜杠打头，/ 斜杠表示地址为：http://ip:port/工程名/ , 映射到 IDEA 代码的 web 目录</span></span><br><span class="line">    RequestDispatcher requestDispatcher = request.getRequestDispatcher(<span class="string">&quot;/servlet2&quot;</span>);</span><br><span class="line">    <span class="comment">//RequestDispatcher requestDispatcher = request.getRequestDispatcher(&quot;http://www.baidu.com&quot;);</span></span><br><span class="line">    <span class="comment">// 走向 Sevlet2（柜台 2）</span></span><br><span class="line">    requestDispatcher.forward(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Servlet2代码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求的参数（办事的材料）查看</span></span><br><span class="line">    String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;在 Servlet2（柜台 2）中查看参数（材料）：&quot;</span> + username);</span><br><span class="line">    <span class="comment">// 查看 柜台 1 是否有盖章</span></span><br><span class="line">    Object key1 = request.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;柜台 1 是否有章：&quot;</span> + key1);</span><br><span class="line">    <span class="comment">// 处理自己的业务</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Servlet2 处理自己的业务 &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="base标签">base标签</h4><p>base 标签设置页面相对路径工作时参照的地址 href 属性就是参数的地址值</p><p><img src="https://static01.imgkr.com/temp/b732edd2ff434e7aa172da925d390a51.png" /></p><h4 id="web-中的相对路径和绝对路径">Web 中的相对路径和绝对路径</h4><ul><li>相对路径是： . 表示当前目录 .. 表示上一级目录 资源名 表示当前目录/资源名</li><li><p>绝对路径： http://ip:port/工程路径/资源路径</p></li><li><p>在实际开发中，路径都使用绝对路径，而不简单的使用相对路径。</p><ul><li>绝对路径</li><li>base+相对</li></ul></li><li><p>web 中 / 斜杠的不同意义</p><ul><li><p>在 web 中 / 斜杠 是一种绝对路径。 / 斜杠 如果被浏览器解析，得到的地址是：http://ip:port/</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>斜杠<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>/ 斜杠 如果被服务器解析，得到的地址是：http://ip:port/工程路径</p><ul><li><p><url-pattern>/servlet1</url-pattern></p></li><li><p>servletContext.getRealPath(“/”);</p></li><li><p>request.getRequestDispatcher(“/”);</p><p>特殊情况： response.sendRediect(“/”); 把斜杠发送给浏览器解析。得到 http://ip:port/</p></li></ul></li></ul></li></ul><h3 id="httpservletresponse类">HttpServletResponse类</h3><ol type="1"><li>作用：HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。</li><li>HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息，我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 对象来进行设置。</li><li>字节流 getOutputStream(); 常用于下载（传递二进制数据） 字符流 getWriter(); 常用于回传字符串（常用） 两个流同时只能使用一个。 使用了字节流，就不能再使用字符流，反之亦然，否则就会报错。</li></ol><h4 id="如何往客户端回传数据">如何往客户端回传数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 它会同时设置服务器和客户端都使用 UTF-8 字符集，还设置了响应头</span></span><br><span class="line">    <span class="comment">// 此方法一定要在获取流对象之前调用才有效</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);<span class="comment">//处理中文乱码</span></span><br><span class="line">    <span class="comment">//要求 ： 往客户端回传 字符串 数据。</span></span><br><span class="line">    PrintWriter writer = response.getWriter();</span><br><span class="line">    writer.write(<span class="string">&quot;response&#x27;s content!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="请求重定向">请求重定向</h4><p>请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求重定向（因为之前的地址可能已经被废弃）。</p><p><img src="https://static01.imgkr.com/temp/adb8004fff4d436c9ea8998faf6484ef.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;曾到此一游&quot;</span>);</span><br><span class="line">    <span class="comment">//重定向方法一</span></span><br><span class="line">    response.setStatus(<span class="number">302</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;/phpstudy/helloNew&quot;</span>);</span><br><span class="line">    <span class="comment">//重定向方法二</span></span><br><span class="line">    response.sendRedirect(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb学习-Tomcat</title>
    <link href="/2021/05/25/JavaWeb%E5%AD%A6%E4%B9%A0-Tomcat/"/>
    <url>/2021/05/25/JavaWeb%E5%AD%A6%E4%B9%A0-Tomcat/</url>
    
    <content type="html"><![CDATA[<h3 id="javaweb">JavaWeb</h3><p>JavaWeb 是指， 所有通过 Java 语言编写可以通过浏览器访问的程序的总称， 叫 JavaWeb。 JavaWeb 是基于请求和响应来开发的。</p><h3 id="常用web服务器">常用Web服务器</h3><ul><li>Tomcat： 由 Apache 组织提供的一种 Web 服务器， 提供对 jsp 和 Servlet 的支持。 它是一种轻量级的 javaWeb 容器（服务器） ， 也是当前应用最广的 JavaWeb 服务器（免费） 。</li><li>Jboss： 是一个遵从 JavaEE 规范的、 开放源代码的、 纯 Java 的 EJB 服务器， 它支持所有的 JavaEE 规范（免费） 。</li><li>GlassFish： 由 Oracle 公司开发的一款 JavaWeb 服务器， 是一款强健的商业服务器， 达到产品级质量（应用很少） 。</li><li>Resin： 是 CAUCHO 公司的产品， 是一个非常流行的服务器， 对 servlet 和 JSP 提供了良好的支持，性能也比较优良， resin 自身采用 JAVA 语言开发（收费， 应用比较多） 。</li><li>WebLogic： 是 Oracle 公司的产品， 是目前应用最广泛的 Web 服务器， 支持 JavaEE 规范， 而且不断的完善以适应新的开发要求， 适合大型项目（收费， 用的不多， 适合大公司） 。<br /></li><li></li></ul><h3 id="tomcat-服务器和-servlet-版本的对应关系">Tomcat 服务器和 Servlet 版本的对应关系</h3><p>Tomcat: 当前企业常用的版本 7.*、 8.*</p><p>Servlet 程序从 2.5 版本是现在世面使用最多的版本（xml 配置） 到了 Servlet3.0 之后。 就是注解版本的 Servlet 使用。 以 2.5 版本为主线讲解 Servlet 程序。</p><p><img src="https://static01.imgkr.com/temp/49a0516edc544447a0d88d226937aaee.png" /></p><h3 id="tomcat的使用">Tomcat的使用</h3><p>目录介绍</p><ul><li>bin 专门用来存放 Tomcat 服务器的可执行程序</li><li>conf 专门用来存放 Tocmat 服务器的配置文件</li><li>lib 专门用来存放 Tomcat 服务器的 jar 包</li><li>logs 专门用来存放 Tomcat 服务器运行时输出的日记信息</li><li>temp 专门用来存放 Tomcdat 运行时产生的临时数据</li><li>webapps 专门用来存放部署的 Web 工程。</li><li>work 是 Tomcat 工作时的目录， 用来存放 Tomcat 运行时 jsp 翻译为 Servlet 的源码， 和 Session 钝化的目录。</li></ul><h3 id="tomcat部署">Tomcat部署</h3><p>第一种部署方法： 只需要把 web 工程的目录拷贝到 Tomcat 的 webapps 目录下即可。</p><p>第二种部署方法： 找到 Tomcat 下的 conf 目录 下,创建如下的配置文件 ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Context 表示一个工程上下文</span></span><br><span class="line"><span class="comment">     path 表示工程的访问路径:/abc</span></span><br><span class="line"><span class="comment">     docBase 表示你的工程目录在哪里</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/abc&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;E:\book&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>访问这个工程的路径如下:http://ip:port/abc/ 就表示访问 E:目录</p><p>直接访问html页面和从浏览器地址栏输入地址访问，原理完全不同：</p><ul><li>前者使用file://协议</li><li>后者使用http协议与服务器交互展示数据</li></ul><p>ROOT 的工程的访问， 以及 默认 index.html 页面的访问：</p><ul><li>当我们在浏览器地址栏中输入访问地址如下： http://ip:port/ 没有工程名的时候， 默认访问的是 ROOT 工程。</li><li>当我们在浏览器地址栏中输入的访问地址如下： http://ip:port/工程名/ 没有资源名， 默认访问 index.html 页面。</li></ul><h3 id="tomcatidea">Tomcat+IDEA</h3><p>File | Settings | Build, Execution, Deployment | Application Servers 添加本地tomcat文件</p><ul><li>IDEA 中如何创建动态 web 工程 ：<ul><li>创建一个新模块：</li><li>选择你要创建什么类型的模块：<br /></li><li>输入你的模块名， 点击【Finish】 完成创建<br /></li></ul></li><li>工程目录介绍：<ul><li>src：存放编写的java源代码</li><li>web：存放web工程的资源文件，如html，css，js等<ul><li>WEB-INF：受服务器保护的目录，浏览器无法直接访问此目录内容<ul><li>lib：存放第三方jar包</li><li>web.xml：整个动态web工程的配置部署描述文件，可以在这配置很多web工程的组件，比如Servlet程序，Filter过滤器，Listener监视器，Session超时等</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb学习-XML</title>
    <link href="/2021/05/25/JavaWeb%E5%AD%A6%E4%B9%A0-XML/"/>
    <url>/2021/05/25/JavaWeb%E5%AD%A6%E4%B9%A0-XML/</url>
    
    <content type="html"><![CDATA[<h3 id="xml">XML</h3><p>可扩展的标记性语言</p><p>作用：</p><ol type="1"><li>用来保存数据，而且这些数据有自我描述性；</li><li>它还可以作为项目或者模块的配置文件 ；</li><li>还可以作为网络传输数据的格式（现在 JSON 为主）</li></ol><h3 id="xml语法">XML语法</h3><ol type="1"><li><p>文档声明</p></li><li><p>元素（标签）</p><ul><li><p>元素是指从开始标签到结束标签的内容</p></li><li>XML 元素必须遵循以下命名规则 ：<ul><li>名称可以含字母、 数字以及其他的字符<br /></li><li>名称不能以数字或者标点符号开始<br /></li><li>名称不能包含空格</li></ul></li><li><p>xml 中的元素（ 标签） 也 分成 单标签和双标签</p></li></ul></li><li><p>xml 属性</p><ol type="1"><li>属性必须使用引号引起来， 不引会报错示例代码</li></ol></li><li><p>xml 注释</p><p>html 和 XML 注释 一样 : <!-- html 注释 --></p></li><li><p>文本区域（CDATA 区）</p><p>CDATA 语法可以告诉 xml 解析器， 我 CDATA 里的文本内容， 只是纯文本， 不需要 xml 语法解析 CDATA 格式： &lt;[CDATA[ 这里可以把你输入的字符原样显示， 不会解析 xml ]]&gt;</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- xml 声明 version 是版本的意思 encoding 是编码 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        而且这个&lt;?xml 要连在一起写， 否则会有报错--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        version 是版本号--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        encoding 是 xml 的文件编码--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        standalone=&quot;yes/no&quot; 表示这个 xml 文件是否是独立的 xml 文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Books</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Book</span> <span class="attr">sn</span> = <span class="string">&quot;000001&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Java编程思想<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>Bruce Eckel<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>100.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Book</span> <span class="attr">sn</span> = <span class="string">&quot;000001&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>第一行Java代码<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>李兴华<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>100.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Books</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>所有 XML 元素都须有关闭标签（也就是闭合）<br /></li><li>XML 标签对大小写敏感<br /></li><li>XML 必须正确地嵌套<br /></li><li>XML 文档必须有根元素<br /></li><li>XML 的属性值须加引号<br /></li><li>XML 中的特殊字符</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span><span class="symbol">&amp;gt;</span>   <span class="comment">&lt;!--会解析成&lt;&gt;--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="xml解析">XML解析</h3><p>xml 可扩展的标记语言。 不管是 html 文件还是 xml 文件它们都是标记型文档， 都可以使用 w3c 组织制定的 dom 技术来解析</p><p>document 对象表示的是整个文档（可以是 html 文档， 也可以是 xml 文档） 早期 JDK 为我们提供了两种 xml 解析技术 DOM 和 Sax 简介（已经过时， 但我们需要知道这两种技术） dom 解析技术是 W3C 组织制定的， 而所有的编程语言都对这个解析技术使用了自己语言的特点进行实现。 Java 对 dom 技术解析标记也做了实现。</p><p>sun 公司在 JDK5 版本对 dom 解析技术进行升级： SAX（ <font color = "red">Simple API for XML </font>） SAX 解析， 它跟 W3C 制定的解析不太一样。 它是以类似事件机制通过回调告诉用户当前正在解析的内容。 它是一行一行的读取 xml 文件进行解析的。 不会创建大量的 dom 对象。 所以它在解析 xml 的时候， 在内存的使用上。 和性能上。 都优于 Dom 解析。 第三方的解析：</p><ul><li>jdom 在 dom 基础上进行了封装 、</li><li>dom4j 又对 jdom 进行了封装。</li><li>pull 主要用在 Android 手机开发， 是在跟 sax 非常类似都是事件机制解析 xml 文件。 （这个 Dom4j 它是第三方的解析技术。 我们需要使用第三方给我们提供好的类库才可以解析 xml 文件。）</li></ul><h3 id="dom4j-解析技术-重点">dom4j 解析技术 (<font color = "red">重点  </font>)</h3><p>由于 dom4j 它不是 sun 公司的技术， 而属于第三方公司的技术， 我们需要使用 dom4j 就需要到 dom4j 官网下载 dom4j的 jar 包</p><h4 id="dom4j编程步骤">dom4j编程步骤：</h4><ol type="1"><li>第一步： 先加载 xml 文件创建 Document 对象</li><li>第二步： 通过 Document 对象拿到根元素对象</li><li>第三步： 通过根元素.elelemts(标签名); 可以返回一个集合， 这个集合里放着。 所有你指定的标签名的元素对象</li><li>第四步： 找到你想要修改、 删除的子元素， 进行相应在的操作</li><li>第五步， 保存到硬盘上</li></ol><h4 id="获取document对象及遍历获取标签中内容">获取document对象及遍历，获取标签中内容</h4><p>创建一个 lib 目录， 并添加 dom4j 的 jar 包。 并添加到类路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//读取test.xml文件生成Book类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> DocumentException </span>&#123;</span><br><span class="line">    <span class="comment">//需要分四步操作:</span></span><br><span class="line">    <span class="comment">//// 第一步， 通过创建 SAXReader 对象。 来读取 xml 文件， 获取 Document 对象</span></span><br><span class="line">    SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    Document document = saxReader.read(<span class="string">&quot;src/com/crazyalice/xml/test.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//// 第二步， 通过 Document 对象。 拿到 XML 的根元素对象(JUnit中相对路径从模块名开始)</span></span><br><span class="line">    Element rootElement = document.getRootElement();</span><br><span class="line">    <span class="comment">//// 第三步， 通过根元素对象。 获取所有的 book 标签对象</span></span><br><span class="line">    List&lt;Element&gt; books = rootElement.elements(<span class="string">&quot;Book&quot;</span>);</span><br><span class="line">    <span class="comment">//// 第四步， 遍历每个 book 标签对象。 然后获取到 book 标签对象内的每一个元素， 再通过 getText() 方法拿到起始标签和结束标签之间的文本内容</span></span><br><span class="line">    <span class="keyword">for</span>(Element book:books) &#123;</span><br><span class="line">        <span class="comment">// Element.asXML() 它将当前元素转换成为 String 对象</span></span><br><span class="line">        System.out.println(book.asXML());</span><br><span class="line">        <span class="comment">// 拿到 book 下面的 name 元素对象</span></span><br><span class="line">        Element nameElement = book.element(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 拿到 book 下面的 price 元素对象</span></span><br><span class="line">        Element priceElement = book.element(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">        <span class="comment">// 拿到 book 下面的 author 元素对象</span></span><br><span class="line">        Element authorElement = book.element(<span class="string">&quot;author&quot;</span>);</span><br><span class="line">        <span class="comment">// 再通过 getText() 方法拿到起始标签和结束标签之间的文本内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;书名:&quot;</span> + nameElement.getText() + <span class="string">&quot; , 价格:&quot;</span></span><br><span class="line">                + priceElement.getText() + <span class="string">&quot;, 作者： &quot;</span> + authorElement.getText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础细节10-反射</title>
    <link href="/2021/05/16/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%8210-%E5%8F%8D%E5%B0%84/"/>
    <url>/2021/05/16/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%8210-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h3 id="java-reflection">Java Reflection</h3><ul><li>反射被视为动态语言的关键，反射机制允许程序在执行期，借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</li><li>加载完类后，在堆内存的方法区中产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息，我们可以通过这个对象看到类的结构。</li><li>动态语言：运行时可以改变结构的语言，静态则相反<ul><li>Java不是动态语言，但Java具有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。</li></ul></li><li>Java反射机制提供的功能：<ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ul></li><li>Java反射主要的API<ul><li>java.lang.Class：代表一个类</li><li>java.lang.reflect.Method：代表类的方法</li><li>java.lang.reflect.Field：代表类的成员变量</li><li>java.lang.reflect.Constructor：代表类的构造器</li><li>......</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br><span class="line"><span class="comment">//1. 通过反射创建Person类的对象</span></span><br><span class="line">Constructor constructor = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">Object b = constructor.newInstance(<span class="string">&quot;B&quot;</span>, <span class="number">10</span>);</span><br><span class="line">Person p = (Person) b;</span><br><span class="line">System.out.println(p.toString());</span><br><span class="line"><span class="comment">//2. 通过反射调用对象指定的属性、方法</span></span><br><span class="line">Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">age.set(p,<span class="number">10</span>);</span><br><span class="line">System.out.println(p.getAge());</span><br><span class="line">Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">show.invoke(p);</span><br><span class="line"><span class="comment">//3. 通过反射调用类的私有结构，如私有构造器、方法、属性</span></span><br><span class="line"><span class="comment">//私有构造器</span></span><br><span class="line">Constructor declaredConstructor = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Person c = (Person)declaredConstructor.newInstance(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">System.out.println(c.toString());</span><br><span class="line"><span class="comment">//私有属性</span></span><br><span class="line">Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">name.set(p,<span class="string">&quot;B+&quot;</span>);</span><br><span class="line">System.out.println(p);</span><br></pre></td></tr></table></figure><h4 id="对java.lang.class类的理解">对java.lang.Class类的理解</h4><ol type="1"><li><p>类的加载过程</p><p>程序经过javac.exe命令后，会生成一个或多个字节码文件(.class)，接着我们用java.exe对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就称为类的加载。加载到内存中的类，我们成为运行时类，此运行时类就作为Class的一个实例。</p></li><li><p>换言之，Class的实例就对应着一个运行时类</p></li><li><p>加载到内存中的运行时类会缓存一定时间，在此时间之内，我们可以通过不同的方式来获取此运行时类</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：调用运行时类的属性：.class</span></span><br><span class="line">Class clazz1 = Person.class;</span><br><span class="line"><span class="comment">//方式二：通过运行时类的对象，调用getClass()</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">Class clazz2 =  person.getClass();</span><br><span class="line"><span class="comment">//方式三：调用Class的静态方法forname(String classPath)</span></span><br><span class="line">Class clazz3 = Class.forName(<span class="string">&quot;com.java.together.Person&quot;</span>);</span><br><span class="line"><span class="comment">//方式四：使用类的加载器</span></span><br><span class="line">ClassLoader classLoader = 当前类名.class.getClassLoader();<span class="comment">//获取当前自定义类的加载器（系统加载器）</span></span><br><span class="line">ClassLoader classLoader1 = classLoader.getParent();<span class="comment">//获取上层扩展类加载器</span></span><br><span class="line"><span class="comment">//调用扩展类加载器的getParent()是无法获取引导类加载器的</span></span><br><span class="line"><span class="comment">//引导类加载器主要负责加载java的核心类库，无法加载自定义类</span></span><br><span class="line">Class clazz4 = classLoader.loadClass(<span class="string">&quot;com.java.together.Person&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java SE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础细节9-网络编程</title>
    <link href="/2021/05/16/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%829-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/05/16/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%829-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="概述">概述</h3><ul><li>Java提供了网络类库，联网底层细节隐藏在Java本机安装系统里，由JVM控制。<ul><li>Java实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境</li></ul></li><li>通信要素：IP和端口号<ul><li>Java中使用InetAddress类代表IP</li><li>如何实例化InetAddress类？</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InetAddress ip1 = InetAddress.getByName(<span class="string">&quot;192.168.0.1&quot;</span>);</span><br><span class="line">InetAddress ip2 = InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">InetAddress ip3 = InetAddress.getLocalHost();</span><br><span class="line">ip2.getHostAddress();</span><br><span class="line">ip2.getHostName();</span><br></pre></td></tr></table></figure><ul><li>​ 端口和IP地址组合得出一个网络套接字：Socket</li></ul><h3 id="实现tcp的网络编程">实现TCP的网络编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Socket socket1 = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">        InetAddress ip1 = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        socket1 = <span class="keyword">new</span> Socket(ip1, <span class="number">58899</span>);</span><br><span class="line">        <span class="comment">//2. 获取一个输出流，用于输出数据</span></span><br><span class="line">        outputStream = socket1.getOutputStream();</span><br><span class="line">        <span class="comment">//3. 写出数据的操作</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;你好，这边是客户端！&quot;</span>.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4. 资源关闭</span></span><br><span class="line">        <span class="keyword">if</span> (socket1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">58899</span>);</span><br><span class="line">        <span class="comment">//2. 调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">        socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">//3. 获取输入流</span></span><br><span class="line">        is = socket.getInputStream();</span><br><span class="line">        <span class="comment">//4. 读取输入流中的数据</span></span><br><span class="line">        baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//5. 资源关闭</span></span><br><span class="line">        <span class="keyword">if</span>(baos!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(is!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(serverSocket!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="udp网络编程">UDP网络编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">    String str = <span class="string">&quot;这是一个UDP发送&quot;</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] data = str.getBytes();</span><br><span class="line">    InetAddress inetAddress = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(data,<span class="number">0</span>,data.length,inetAddress,<span class="number">58899</span>);</span><br><span class="line">    datagramSocket.send(datagramPacket);</span><br><span class="line"></span><br><span class="line">    datagramSocket.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramSocket datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">58899</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">    DatagramPacket datagramPacket = <span class="keyword">new</span> DatagramPacket(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line">    datagramSocket.receive(datagramPacket);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(datagramPacket.getData(),<span class="number">0</span>,datagramPacket.getLength()));</span><br><span class="line"></span><br><span class="line">    datagramSocket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java SE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础细节8-IO流</title>
    <link href="/2021/05/16/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%828-IO%E6%B5%81/"/>
    <url>/2021/05/16/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%828-IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h3 id="流的分类">流的分类</h3><ol type="1"><li>操作数据单位：字节流、字符流</li><li>数据的流向：输入流、输出流</li><li>流的角色：节点流、处理流</li></ol><h4 id="流的体系结构">流的体系结构</h4><table><thead><tr class="header"><th>抽象基类</th><th>节点流（或文件流）</th><th>缓冲流（处理流的一种）</th></tr></thead><tbody><tr class="odd"><td>InputStream</td><td>FileInputStream</td><td>BufferedInputStream</td></tr><tr class="even"><td>OutputStream</td><td>FileOutputStream</td><td>BufferedOutputStream</td></tr><tr class="odd"><td>Reader</td><td>FileReader</td><td>BufferedReader</td></tr><tr class="even"><td>Writer</td><td>FileWriter</td><td>BufferedWriter</td></tr></tbody></table><p>InputStream, OutputStream处理字节，Reader, Writer处理字符</p><h4 id="读入数据">读入数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IOStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.实例化File类对象，指明要操作的文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\浮士德\\Desktop\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2.提供具体的流</span></span><br><span class="line">        fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="comment">//3.数据的读入，返回读取的字符，如果到达文件末尾，返回-1</span></span><br><span class="line">        <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">while</span>((data= fileReader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//4.流的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fileReader!=<span class="keyword">null</span>)</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>异常处理：为了保证流资源一定可以执行关闭操作，需要使用try-catch-finally处理</li><li>读入的文件一定要存在，否则会报FileNotFoundException</li></ul><h4 id="写出数据">写出数据</h4><ul><li>输出操作对应的File可以不存在，并不会报异常</li><li>File对应的硬盘中文件如果不存在，在输出过程中会自动创建此文件</li><li>File对应的硬盘中文件如果存在：<ul><li>如果流使用的构造器是：FileWriter(file,false)/FileWriter(file)，则会对原文件进行覆盖</li><li>如果流使用的构造器是：FileWriter(file,true)，则会在原文件末尾进行添加</li></ul></li></ul><p>注：字符流不能处理图片文件，字节流处理文本文件可能出现乱码</p><p>结论：对于文本文件，使用字符流处理，对于非文本文件，使用字节流处理</p><p>​ 如果对文件不涉及读取操作，可以使用字节流复制文本文件</p><h4 id="非文本文件的复制使用缓冲流包住节点流速度更快">非文本文件的复制（使用缓冲流包住节点流，速度更快）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IOStreamTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BufferedInputStream bufferedInputStream = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream bufferedOutputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File srcfile = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\浮士德\\Desktop\\龙与虎.jpg&quot;</span>);</span><br><span class="line">        File destfile = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\浮士德\\Desktop\\龙与虎2.jpg&quot;</span>);</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(srcfile);</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(destfile);</span><br><span class="line">        bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br><span class="line">        bufferedOutputStream = <span class="keyword">new</span> BufferedOutputStream(fileOutputStream);</span><br><span class="line">        <span class="keyword">byte</span>[] bbuff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bufferedInputStream.read(bbuff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bufferedOutputStream.write(bbuff, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">        <span class="keyword">if</span>(bufferedInputStream!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bufferedInputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(bufferedOutputStream!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bufferedOutputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//关闭外层流时，内层的流也会自动关闭，因此可以省略</span></span><br><span class="line">        <span class="comment">//fileInputStream.close();</span></span><br><span class="line">        <span class="comment">//fileOutputStream.close();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理流之一缓冲流">处理流之一：缓冲流</h4><ul><li>使用内部提供的缓冲区，提高流读取和写入的速度</li><li>处理流，就是“套接”在已有流的基础上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\浮士德\\Desktop\\hello.txt&quot;</span>)));</span><br><span class="line">bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\浮士德\\Desktop\\hello1.txt&quot;</span>)));</span><br><span class="line"><span class="comment">//读写操作方式一</span></span><br><span class="line"><span class="keyword">char</span>[] cbuff = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = br.read(cbuff))!=-<span class="number">1</span>) &#123;</span><br><span class="line">    bw.write(cbuff, <span class="number">0</span>, len);</span><br><span class="line">    bw.flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读写操作方式二</span></span><br><span class="line">String data;</span><br><span class="line"><span class="keyword">while</span>((data = br.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    bw.write(data);</span><br><span class="line">    bw.newline();<span class="comment">//换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理流之二转换流">处理流之二：转换流</h4><ol type="1"><li><p>转换流：属于字符流</p><p>InputStreamReader:将一个字节的输入流转换为字符的输入流</p><p>OutputStreamWriter:将一个字符的输出流转换为字节的输出流</p></li><li><p>作用：提供字节流与字符流之间的转换</p><p>解码：字节--&gt;字符</p><p>编码：字符--&gt;字节</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\浮士德\\Desktop&quot;</span>);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis);<span class="comment">//使用系统默认的字符集</span></span><br><span class="line"><span class="comment">//参数二指明了使用的字符集，具体使用的字符集取决于读取的文件保存时使用的字符集</span></span><br><span class="line">InputStreamReader isr1 = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="字符集">字符集</h3><ul><li>ASCII：美国标准信息交换码，用一个字节的7位即可表示</li><li>ISO8859-1：拉丁码表，欧洲码表，用一个字节的8位表示</li><li>GB2312：中国的中文编码表，最多两个字节编码所有字符</li><li>GBK：中国的中文编码表升级，融合更多中文文字符号，最多两个字节编码</li><li>Unicode：国际标准码，融合了目前人类使用的所有字符，为每个字符分配唯一的字符码，所有文字都用两个字节来表示</li><li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符</li></ul><h3 id="其他流">其他流</h3><ol type="1"><li>标准的输入、输出流<ul><li>System.in：标准输入流，默认从键盘输入</li><li>System.out：标准输出流，默认从控制台输出</li><li>System类的setIn(InputStream is)/setOut(PrintStream ps)方式重新指定输入和输出流</li></ul></li><li>打印流<ul><li>PrintStream和PrintWriter</li><li>提供了一系列重载的print()和Println()方法，用于多种数据类型的输出</li><li>System.out返回的是PrintStream的实例</li></ul></li><li>数据流<ul><li>DataInputStream和DataOutputStream</li><li>作用：用于读取或写出基本数据类型的变量或字符串</li></ul></li></ol><h3 id="对象流">对象流</h3><ul><li>ObjectInputStream和ObjectOutputStream<ul><li>作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把java中的对象写入到数据源中，也能把对象从数据源中还原回来</li><li>序列化：用ObjectOutputStream类<font color = "blue">保存</font>基本类型数据或对象的机制</li><li>反序列化：用ObjectInputStream类<font color = "blue">读取</font>基本类型数据或对象的机制</li><li>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</li></ul></li><li>对象的序列化：允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点，当其他程序获取了这种二进制流，就可以恢复成原来的Java对象<ul><li>序列化的好处在于可将任何实现了Serialiazable接口的对象转化为字节数据，使其在保存和传输时可还原</li><li>序列化机制是JavaEE平台的基础</li><li>如果需要让某个对象支持序列化机制，则必须要让对象所属的类及其属性是可序列化的，为了让某个类可序列化，该类必须实现以下两个接口之一，否则会抛NotSerializableException<ul><li>Serializable</li><li>Externalizable</li></ul></li><li>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量<ul><li>private static final long serialVersionUID</li><li>serialVersionUID用来表明类的不同版本间的兼容性，其目的是对序列化对象进行版本控制，有关各版本反序列化时是否兼容</li><li>如果类没有显示定义这个静态常量，它的值是java运行时环境根据类的内部细节自动生成的，若类的实例变量做了修改，serialVersionUID可能发生变化，故建议，显式声明</li></ul></li></ul></li><li><p>序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去</p><ul><li>通过ObjectOutputStream实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObjectOutputStreamTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\浮士德\\Desktop\\hello.txt&quot;</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> String(<span class="string">&quot;来了来了&quot;</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(oos!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反序列化：将磁盘文件中的对象还原为内存中的一个java对象</p><ul><li>使用ObjectInputStream实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ObjectInputStreamTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\浮士德\\Desktop\\hello.txt&quot;</span>));</span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        String str = (String) obj;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ois!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>自定义类实现序列化和反序列化时需要注意<ul><li>需要实现接口Serializable</li><li>当前类提供一个全局常量：serialVersionUID用于确定原类版本，若无此常量，当自定义类的实例序列化后，若原类发生改变，此实例反序列化将找不到原来的类，报异常</li><li>除了当前类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的（默认情况下，基本数据类型可序列化）</li><li>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</li></ul></li></ul><h3 id="随机存取文件流">随机存取文件流</h3><ul><li>RandomAccessFile，<ul><li>直接继承于Object类，</li><li>实现了DataInput和DataOutput接口，既可以作为输入流，也可以作为输出流</li><li>构造器<ul><li>File file, String mode</li><li>String name, String mode</li><li>mode参数指定其访问模式<ul><li>r：以只读方式打开</li><li>rw：打开以便读取和写入</li><li>rwd：打开以便读取和写入：同步文件内容的更新</li><li>rws：打开以便读取和写入：同步文件内容和元数据的更新</li></ul></li><li>如果模式为只读r，则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常，如果模式为rw读写，如果这个文件不存在则会去创建文件，如果存在则不会创建。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">raf1 = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\浮士德\\Desktop\\龙与虎.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">raf2 = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\浮士德\\Desktop\\龙与虎1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = raf1.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    raf2.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>​ RandomAccessFile作为输出流时，写出的文件如果不存在，则在执行过程中自动生成，如果写出到的文件存在，则会对原有文件内容进行覆盖，而且默认情况下从头覆盖</li><li>存在seek方法将指针调整到角标指定的位置</li></ul><h3 id="nio">NIO</h3><ul><li>（New IO，Non-Blocking IO）从java1.4版本开始引入的新IO API</li><li>NIO支持面向缓冲区的、基于通道的IO操作（IO是面向流的）</li><li>NIO将以更高效的方式进行文件的读写操作</li><li>JAVA API中提供了两套NIO，一套是针对标准输入输出NIO，另一套是网络编程NIO</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java SE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础细节7-泛型和File</title>
    <link href="/2021/05/15/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%827-%E6%B3%9B%E5%9E%8B%E5%92%8CFile/"/>
    <url>/2021/05/15/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%827-%E6%B3%9B%E5%9E%8B%E5%92%8CFile/</url>
    
    <content type="html"><![CDATA[<h3 id="泛型">泛型</h3><ul><li><p>概念：泛型就是，允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。</p></li><li><p>JDK1.5以后，Java引入了“参数化类型”的概念，允许在创建集合时再指定集合元素的类型</p></li><li><p>JDK1.5改写了集合框架中全部的类和接口，为这些类和接口增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参</p></li><li><p>总结</p><ul><li>集合接口或集合类在jdk5.0时都修改为带泛型的结构</li><li>在实例化集合类时可以指明具体的类型</li><li>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构使用到类的泛型的位置，都指定为实例化的泛型类型</li><li>注意：泛型的类型必须是类，不能是基本数据类型，需要用到基本数据类型的地方用包装类替代</li><li>如果实例化时没有指明泛型类型，默认类型为Object类型</li></ul></li><li><p>自定义泛型结构：泛型类，泛型接口，泛型方法</p><ul><li><p>如果定义了带泛型的类，建议在实例化时要指明类的泛型</p></li><li><p>由于子类在继承带泛型的父类时，指明了泛型类型，则子类实例化时不需再指明泛型</p><ul><li>若父类没指明泛型类型，子类实例化时需要指明</li></ul></li><li><p>注意点：</p><ul><li>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。如&lt;E1,E2,E3&gt;</li><li>泛型类的构造器如下：public GenericClass(){}<ul><li>这种是错误的：public GenericClass<E>(){}</li></ul></li><li>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致</li><li>泛型不同的引用不能互相赋值<ul><li>如：尽管在编译时ArrayList<String>和Array<Integer>是两种类型，但是运行时只有一个ArrayList被加载到Jvm中</li></ul></li><li>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价与Object。<ul><li>经验：泛型要使用，一路都用，要不是用，一路都不要用</li></ul></li><li>如果泛型类是一个接口或抽象类，则不可以创建泛型类的对象</li><li>jdk1.7，泛型的简化操作：ArrayList<Fruit> flist = new ArrayList&lt;&gt;();</li><li>泛型的指定中不能使用基本的数据类型，可以使用包装类替换</li><li>类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。</li><li>异常类不能是泛型的</li><li>不能使用new E[]。但是可以： E[] elements = (E[])new Object[capacity];<ul><li>参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组</li></ul></li><li>父类有泛型，子类可以选择保留泛型，也可以选择指定泛型类型<ul><li>子类不保留父类的泛型：按需实现<ul><li>没有类型 ：擦除</li><li>具体类型</li></ul></li><li>子类保留父类的泛型：泛型子类<ul><li>全部保留</li><li>部分保留</li></ul></li></ul></li><li>结论：子类除了指定或保留父类的泛型，还可以增加自己的泛型</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="comment">//子类不保留父类泛型</span></span><br><span class="line"><span class="comment">//1. 没有类型，擦除(下面两种等价）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Object</span>,<span class="title">Object</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="comment">//2. 具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">String</span>,<span class="title">Integer</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="comment">//子类保留父类的泛型</span></span><br><span class="line"><span class="comment">//1. 全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>,<span class="title">A</span>,<span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="comment">//2.部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son5</span>&lt;<span class="title">T1</span>,<span class="title">A</span>,<span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>,<span class="title">Integer</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>泛型方法：方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系<ul><li>换言之，泛型方法所属的类是不是泛型类都没有关系</li><li>泛型方法可以声明为静态，因为泛型参数是在调用方法时确定的，并非在实例化类时确定</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyFromList</span><span class="params">(E[] arr)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;E&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(E e:arr)</span><br><span class="line">            arrayList.add(e);</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型在继承方面的体现">泛型在继承方面的体现</h4><ul><li>若类A是类B的父类，G<A>和G<B>两者不具备子父类关系，两者是并列关系，不能利用多态性<ul><li>若类A是类B的父类，A<G>和B<G>依然具备父子类关系</li></ul></li></ul><h4 id="通配符">通配符</h4><p>通配符的使用可以解决上述问题</p><p>类A是类B的父类，G<A>和G<B>两者不具备子父类关系，但两者共同的父类是G&lt;?&gt;</p><p>注：对于LIst&lt;?&gt;，除了null不能向内部添加数据，否则会破坏其数据一致性</p><h4 id="有限制条件的通配符">有限制条件的通配符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Person&gt; list1 = <span class="keyword">null</span>;<span class="comment">//Person及其子类即可</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> Person&gt; list2 = <span class="keyword">null</span>;<span class="comment">//Person及其父类即可</span></span><br><span class="line">List&lt;Student&gt; list3 = <span class="keyword">null</span>;</span><br><span class="line">List&lt;Person&gt; list4 = <span class="keyword">null</span>;</span><br><span class="line">List&lt;Object&gt; list5 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">list1 = list3;</span><br><span class="line">list1 = list4;</span><br><span class="line">list1 = list5;<span class="comment">//报错</span></span><br><span class="line">list2 = list3;<span class="comment">//报错</span></span><br><span class="line">list2 = list4;</span><br><span class="line">list2 = list5;</span><br></pre></td></tr></table></figure><ul><li>G&lt;? extends A&gt; A及其子类</li><li>G&lt;? super A&gt; A及其父类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多态的cases</span></span><br><span class="line">Person p1 = list1.get(<span class="number">0</span>);</span><br><span class="line">Student s1 = list1.get(<span class="number">0</span>);  <span class="comment">//编译不通过</span></span><br><span class="line">Person p2 = list2.get(<span class="number">0</span>);   <span class="comment">//编译不通过</span></span><br><span class="line">Object o1 = list2.get(<span class="number">0</span>);</span><br><span class="line">list1.add(<span class="keyword">new</span> Student());   <span class="comment">//编译不通过</span></span><br><span class="line">list2.add(<span class="keyword">new</span> Person());</span><br><span class="line">list2.add(<span class="keyword">new</span> Student());</span><br></pre></td></tr></table></figure><h3 id="file">File</h3><ul><li>File类的一个对象，代表一个文件或一个文件目录（即文件夹）</li><li>File类声明在java.io包下</li><li>路径分隔符：<ul><li>Windows下：\<br /></li><li>Unix:/</li></ul></li><li>创建File类实例(仅为内存层面的对象，暂不考虑硬盘上是否由此文件或目录)<ul><li>File(String filePath)</li><li>File(String parent,String child)</li><li>File(File parentFiles,String childPath)</li></ul></li><li>常用方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAbsolutePath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParent</span><span class="params">()</span><span class="comment">//获取上层文件目录，若无，返回null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span><span class="comment">//获取文件长度，不能对目录使用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span><span class="comment">//最后修改时间，毫秒值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String[] <span class="title">list</span><span class="params">()</span><span class="comment">//获取指定目录下所有文件或目录的名称数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File[] <span class="title">listFiles</span><span class="params">()</span><span class="comment">//获取指定目录下所有文件或目录的File数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span><span class="comment">//把文件重命名为指定的文件路径</span></span></span><br><span class="line"><span class="function"><span class="comment">//e.g. file1.renameTo(file2);</span></span></span><br><span class="line"><span class="function"><span class="comment">//renameTo方法要想保证返回true，需要file1在硬盘中存在且file2在硬盘中不存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span>  <span class="comment">//创建文件，若存在则不创建返回falese</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span><span class="comment">//创建目录，若存在则不创建，上层目录不存在则不创建</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span><span class="comment">//创建目录，若上层目录不存在，一并创建</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span><span class="comment">//Java中删除不走回收站！</span></span></span><br><span class="line"><span class="function"><span class="comment">//delete用于删除目录时，该目录下不能有文件或子目录</span></span></span><br></pre></td></tr></table></figure><ul><li>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及写入或读取文件内容的操作，如果需要读取或写入文件内容，需要使用IO流来完成，</li><li>File类对象常作为参数传递到流的构造器中，指明读取或写入的&quot;终点&quot;</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java SE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础细节6-枚举和注解</title>
    <link href="/2021/05/15/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%826-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
    <url>/2021/05/15/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%826-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="枚举类">枚举类</h3><ul><li>类的对象只有有限个，确定的</li><li>当需要定义一组常量时，强烈建议使用枚举类</li><li>如果枚举类中只有一个对象，则可以作为单例模式的实现方式</li><li>枚举类定义：<ul><li>jdk5.0前，自定义枚举类</li><li>jdk5.0，可以使用enum关键字定义枚举类</li></ul></li><li>使用enum关键字定义枚举类，定义的枚举类默认继承与java.lang.Enum类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供当前类的枚举对象，之间用，隔开，末尾用；</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>),AUTUMN(<span class="string">&quot;秋天&quot;</span>), WINTER(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    <span class="comment">//声明Season对象的属性，用private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如有需求可以重写toString更改输出内容或添加get，set方法获取枚举对象属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Enum类的主要方法：<ul><li>values()：返回枚举类型的对象数组，该方法可以很方便地遍历所有的枚举值</li><li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象，要求字符串必须是枚举类对象的名称，如果没有名为str的枚举类对象，则抛异常：IllegalArgumentException</li><li>toString()：返回当前枚举类对象常量的名称</li></ul></li><li>使用enum关键字定义的枚举类实现接口的情况：<ul><li>实现接口，在enum类中实现抽象方法（对每个枚举对象而言方法相同）</li><li>让枚举类的对象分别实现接口中的抽象方法（对每个枚举对象而言方法不相同）</li></ul></li></ul><h3 id="注解annotation">注解（Annotation）</h3><ul><li>JDK5.0开始，Java增加了对元数据（MetaData）的支持，也就是Annotation（注解）</li><li>Annotation是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些信息进行验证或部署</li><li>Annotation可以像修饰符一样被使用，可以修饰<font color = "red">包、类、构造器、方法、成员变量、参数、局部变量的声明</font>&gt;，这些信息被保存在Annotation的&quot;name=value&quot;对中</li><li>JavaSE中注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中遗留的繁冗代码和XML配置等。</li><li>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Structs2有一部分也是基于注解的了。一定程度上可以说：<font color = "blue">框架 = 注解 + 反射 + 设计模式</font>。</li></ul><h3 id="常见注解">常见注解</h3><ul><li>生成文档相关的注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@author</span></span><br><span class="line"><span class="meta">@version</span></span><br><span class="line"><span class="meta">@see</span>参考转向，也就是相关主题</span><br><span class="line"><span class="meta">@since</span></span><br><span class="line"><span class="comment">//下面三个标记只用于方法</span></span><br><span class="line"><span class="meta">@param</span>对方法中参数的说明，没有参数就不能写</span><br><span class="line"><span class="meta">@return</span>对方法中返回值的说明，返回值类型是<span class="keyword">void</span>就不能写</span><br><span class="line"><span class="meta">@exception</span>对方法中可能抛出异常的说明，方法没有用<span class="keyword">throws</span>显示抛出异常就不能写</span><br><span class="line"><span class="comment">//格式说明</span></span><br><span class="line"><span class="meta">@param</span> 形参名 形参类型 形参说明</span><br><span class="line"><span class="meta">@return</span> 返回值类型 返回值说明</span><br><span class="line"><span class="meta">@exception</span> 异常类型 异常说明</span><br><span class="line"><span class="meta">@param</span>和<span class="meta">@exception</span>可以并列多个</span><br></pre></td></tr></table></figure><ul><li>在编译时进行格式检查（JDK内置的三个基本注解）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>限定重写父类方法，该注解只能用于方法</span><br><span class="line"><span class="meta">@Deprecated</span>用于表示修饰的元素（类、方法等）已过时，通常因为所修饰结构危险或存在更好的选择</span><br><span class="line"><span class="meta">@SuppressWarnings</span>抑制编译器警告</span><br></pre></td></tr></table></figure><ul><li><p>跟踪代码依赖性，实现替代配置文件功能</p><p>Servlet3.0提供了注解，使得不再需要在web.xml文件中进行Servlet的部署</p></li></ul><h3 id="自定义注解">自定义注解</h3><ol type="1"><li>定义新的Annotation类型使用@interface关键字</li><li>自定义注解自动继承了java.lang.annotation.Annotation接口</li><li>Annotation的成员变量在Annotation定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型，我们称为配置参数。类型只能是八种基本数据类型、String、Class、enum、Annotation以上所有类型的数组</li><li>可以在定义Annotation的成员变量时为其制定初始值，指定成员变量的初始值可以使用default关键字</li><li>如果只有一个参数成员，建议使用参数名为value</li><li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=”</li><li>没有成员定义的Annotation称为标记，包含成员变量的Annotation成为元数据Annotation</li></ol><p>注意：自定义注释必须配上注解的信息处理流程才有意义</p><ol type="1"><li>注解声明为@interface</li><li>内部定义成员，通常使用value</li><li>可以指定成员的默认值，使用default</li><li>如果自定义注解没有成员，表明是一个标识</li><li>如果注解有成员，在使用注解时需要指明成员的值</li><li>自定义注解必须配上注解的信息处理流程（使用反射）才有意义</li><li>自定义注解通常会指明两个元注解：Retention，Target</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;hi&quot;)</span> <span class="comment">//使用</span></span><br></pre></td></tr></table></figure><h3 id="jdk中的元注解">JDK中的元注解</h3><ul><li><p>JDK的元Annotation用于修饰其他Annotation定义</p></li><li><p>JDK5.0提供了4个标注的meta-annotation类型，分别是：</p><ul><li><p>Retention：指定其修饰的注解的生命周期（SOURCE,CLASS,RUNTIME）</p><p>​ 只有声明为RUNTIME的注解，运行时才能通过反射获取</p></li><li><p>Target：用于指定被修饰的Annotation能用于修饰哪些程序元素</p></li><li><p>Documented：表示所修饰的注解在被javadoc解析时保留下来</p></li><li><p>Inherited：被它修饰的Annotation具有继承性，父类有子类就也有</p></li></ul></li></ul><h3 id="通过反射获取注解信息">通过反射获取注解信息</h3><h3 id="jdk8中注解的新特性">JDK8中注解的新特性</h3><h4 id="可重复注解">可重复注解</h4><p>jdk8.0之前的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@interface</span> MyAnnotations&#123;</span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@MyAnnotation(value = &quot;hi1&quot;)</span></span><br><span class="line"><span class="comment">//@MyAnnotation(value = &quot;hi2&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotations(&#123;@MyAnnotation(value = &quot;hi1&quot;),@MyAnnotation(value = &quot;hi2&quot;)&#125;)</span></span><br></pre></td></tr></table></figure><p>jdk8新特性：</p><ul><li>在MyAnnotation上声明@Repeatable，成员值为Annotation.class</li><li>MyAnnotation的Target，Retention，Inherited等注解和MyAnnotaions相同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;hi1&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;hi2&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="类型注解">类型注解</h4><ul><li>ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中（如泛型声明）</li><li>ElementType.TYPE_USE：表示该注解能卸载使用类型的任何语句中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;@<span class="title">MyAnnotation</span> <span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">throws</span> @MyAnnotation RuntimeException</span>&#123;</span><br><span class="line">        ArrayList&lt;<span class="meta">@MyAnnotation</span> String&gt; strlist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num = (<span class="meta">@MyAnnotation</span> <span class="keyword">int</span>) <span class="number">10L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java SE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础细节5-常用类</title>
    <link href="/2021/05/13/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%825-%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    <url>/2021/05/13/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%825-%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="string">String</h3><ul><li><p>String是final类，代表不可变的字符序列（不可变性）</p><ul><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</li><li>当对现有的字符串进行连续操作时，也需要重新指定内存区域赋值</li><li>调用String的replace()方法修改指定的字符或字符串时，也需要重新指定内存区域赋值</li></ul></li><li><p>字符串是常量，其值在创建之后不能更改</p></li><li><p>String对象的字符内容是存储在一个字符数组value[]中的，final char[] value</p></li><li><p>String实现了Serializable接口，表示字符串支持序列化</p><p>​ 实现了Comparable接口，表示Stirng可以比较大小</p></li><li><p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池</p></li><li><p>字符串常量池中是不会存储内容相同的字符串的</p></li><li><p>String实例化方式：字面量定义/new+构造器</p><ul><li><p>字面量定义的方式，定义的字符串数据声明在方法区中的字符串常量池中</p></li><li><p>new+构造器的方式：此时字符串变量保存的地址值，是数据在对空间中开辟空间后对应的地址值</p></li><li><p>```java String string = new String(&quot;abc&quot;);//创建了两个对象，new的String和常量池中&quot;abc&quot; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- String拼接特性：</span><br><span class="line">  - 常量与常量的拼接结果在常量池，并且常量池中不会存在相同内容的常量</span><br><span class="line">  - 拼接的字符串中只要有一个是变量，结果就在堆中</span><br><span class="line">  - 如果拼接的结果调用intern()方法，返回值就在常量池中</span><br><span class="line">  - final修饰的字符串变量也视作常量</span><br><span class="line">  </span><br><span class="line">- jdk1.6：字符串常量池存储在方法区（永久区）</span><br><span class="line"></span><br><span class="line">  jdk1.7：堆空间</span><br><span class="line"></span><br><span class="line">  jdk1.8：方法区（元空间）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###  String常用方法</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">- int length()</span><br><span class="line">- char charAt(int index)</span><br><span class="line">- boolean isEmpty()</span><br><span class="line">- String toLowerCase()返回副本</span><br><span class="line">- String toUpperCase()返回副本</span><br><span class="line">- String trim()返回字符串副本，忽略前导和尾部空白，保留中间空白</span><br><span class="line">- boolean equals(Object obj)</span><br><span class="line">- boolean equalsIgnoreCase(String anotherString)</span><br><span class="line">- String concat(String str)</span><br><span class="line">- int compareTo(String anotherString)涉及排序</span><br><span class="line">- String substring(int beginIndex)</span><br><span class="line">- String substring(int beginIndex, int endIndex)  左闭右开</span><br><span class="line">- boolean endsWith(Stirng suffix)</span><br><span class="line">- boolean startsWith(String prefix)</span><br><span class="line">- boolean startsWith(Stirng prefix, int toffset)指定位置开始的字符串前缀判断</span><br><span class="line">- boolean contains(CharSequence s)  包含指定的char值序列</span><br><span class="line">- int indexOf(String str)</span><br><span class="line">- int indexOf(String str, int fromIndex) </span><br><span class="line">- int lastIndexOf(String str)</span><br><span class="line">- int lastIndexOf(String str, int fromIndex)</span><br><span class="line">&#x2F;&#x2F;indexOf和lastIndexOf未找到都会返回-1</span><br><span class="line">&#x2F;&#x2F;替换</span><br><span class="line">- Stirng replace(char oldChar, char newChar)</span><br><span class="line">- String replace(CharSequence target, CharSequence replacement) 字面量替换</span><br><span class="line">- String replaceAll(Stirng regex, String replacement)</span><br><span class="line">- String replaceFirst(Stirng regex, String replacement) </span><br><span class="line">&#x2F;&#x2F;匹配</span><br><span class="line">- boolean matches(Stirng regex) 是否匹配给定的正则表达式</span><br><span class="line">&#x2F;&#x2F;切片</span><br><span class="line">- String[] split(Stirng regex)</span><br><span class="line">- String[] split(Stirng regex, int limit)</span><br></pre></td></tr></table></figure></p></li></ul></li></ul><h3 id="string的转换">String的转换</h3><ul><li><p>String-&gt;基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)</p></li><li><p>基本数据类型、包装类-&gt;String：调用String重载的valueOf(xxx)</p></li><li><p>String-&gt;char[]：调用String的toCharArray()</p></li><li><p>char[]-&gt;String：调用String的构造器</p></li><li><p>String-&gt;byte[]：调用String的getBytes(charsetName:)可选参数为编码字符集（编码）</p></li><li><p>byte[]-&gt;String：调用String的构造器（解码）</p></li><li><p>String-&gt;StringBuffer,StringBuilder：调用StringBuffer，StringBuilder的构造器</p></li><li><p>StringBuffer,StringBuilder-&gt;String:1.调用StringBuffer,StringBuilder的toStirng()</p><p>​ 2.调用String的构造器</p></li></ul><h3 id="stringstringbuffer和stringbuilder">String，StringBuffer和StringBuilder</h3><ul><li><p>三者异同：</p><ul><li>String：不可变的字符序列，底层使用char[]</li><li>StringBuffer：可变的字符序列，线程安全的，效率低，底层使用char[]</li><li>StringBuilder：可变的字符序列，线程不安全，效率高（jdk5.0新增），底层使用char[]</li></ul></li><li><p>注意1：StringBuffer和StringBuilder对象调用length方法返回实际的字符串长度</p><p>​ 两者初始化的char[]长度为16，也可使用带capacity参数的构造器自主申请char[]长度</p></li><li><p>注意2：扩容问题：如果要添加的数据底层数组放不下了，就需要扩容底层数组。</p><p>​ 默认情况下，扩容为原来容量的2倍+2，同时将原有数组的元素赋值到新的数组。</p></li><li><p>常用方法（以StirngBuffer为例，StringBuilder基本相同）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(xxx)</span></span></span><br><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span><span class="comment">//左闭右开</span></span></span><br><span class="line"><span class="function">StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end, String str)</span><span class="comment">//左闭右开</span></span></span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset,xxx)</span></span></span><br><span class="line"><span class="function">StringBuffer <span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Stirng str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span><span class="comment">//左闭右开,返回副本</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">cahrAt</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> ch)</span></span></span><br></pre></td></tr></table></figure><p>三者效率：StringBuilder&gt;StringBuffer&gt;String</p><h3 id="java比较器">java比较器</h3><h4 id="自然排序comparable接口与自定义类">自然排序：Comparable接口与自定义类</h4><ol type="1"><li>String、包装类等实现了Comparable接口，重写了compareTo(obj)方法</li><li>String、包装类重写compareTo()方法后，进行了从小到大的排列</li><li>重写compareTo(obj)的规则：<ul><li>如果当前对象this大于形参对象obj，则返回正整数；</li><li>如果当前对象this小于形参对象obj，则返回负整数；</li><li>如果当前对象this等于形参对象obj，则返回0；</li></ul></li><li>对于自定义类，如果需要排序，可以让自定义类实现Comparable接口，重写compareTo(obj)，在compareTo方法中指明如何排序</li></ol><h4 id="定制排序java.util.comparator">定制排序：java.util.Comparator</h4><ul><li>当元素类型没有实现Comparable接口而又不方便修改代码，或实现的Comparable接口排序规则不适合当前的操作，那么可以考虑使用Comparator的对象来排序，强行对多个对象进行整体排序的比较；</li><li>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：若返回正整数，则表示o1大于o2；如果返回0则表示相等；返回负整数表示o1小于o2；</li><li>可以将Comparator传递给sort方法，如collections.sort或Arrays.sort，从而允许在排序顺序上实现精确控制；</li><li>还可以使用Comparator来控制某些数据结构，如有序set或有序映射的顺序，或者为那些没有自然顺序的对象collection提供排序；</li></ul><h4 id="对比">对比</h4><p>Comparable接口方式一旦指定，保证其实现类的对象在任何位置都可以比较大小</p><p>Comparator属性临时性比较，可以由新建匿名对象来实现比较规则</p><h3 id="system类">System类</h3><ul><li>系统类：位于java.lang包，系统级很多属性和控制方法都在类的内部</li><li>该类构造器是private的，无法实例化，内部成员变量和方法都是static的<ul><li>包含三个成员变量：in、out和err，分别代表标准输入流（键盘输入）、标准输出流（显示器）和标准错误输出流（显示器）。</li></ul></li></ul><h3 id="math类">Math类</h3><h3 id="biginteger和bigdecimal">BigInteger和BigDecimal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">&quot;123123123123123123123123123123123123123123&quot;</span>);</span><br><span class="line">System.out.println(bi);</span><br><span class="line">BigDecimal bd1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.56489456651&quot;</span>);</span><br><span class="line">BigDecimal bd2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">System.out.println(bd1.divide(bd2,BigDecimal.ROUND_HALF_UP));</span><br><span class="line">System.out.println(bd1.divide(bd2,<span class="number">15</span>,BigDecimal.ROUND_HALF_UP));</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java SE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础细节4-多线程</title>
    <link href="/2021/05/10/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%824-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/05/10/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%824-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="基本概念程序进程线程">基本概念：程序、进程、线程</h3><ul><li>程序program：完成特定任务、用某种语言编写的指令的集合，即指一段静态的代码</li><li>进程process：是程序的一次执行过程，或是正在运行的一个程序，是一个动态的过程：有它自身的产生、存在和消亡的过程。--生命周期</li><li>线程thread：进程可以进一步细化为线程，是一个程序内部的一条执行路径。<ul><li>若一个进程同一时间并行执行多个线程，就是支持多线程的；</li><li>线程作为调度和执行的单位，每个线程都有独立的运行栈和程序计数器pc，线程切换的开销小；</li><li>一个进程中的多个线程共享相同的内存单元/内存地址空间--&gt;它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效，但多个线程操作共享的系统资源可能会带来安全的隐患。（一个进程共享一个方法区和堆，有各自的栈和pc）</li></ul></li><li>一个Java应用程序java.exe，至少有三个线程，main()主线程，gc()垃圾回收线程，异常处理线程。如果发生异常会影响主线程。</li><li>并行与并发<ul><li>并行：多个CPU同时执行多个任务</li><li>并发：一个CPU采用时间片同时执行多个任务</li></ul></li></ul><h3 id="多线程的创建">多线程的创建</h3><ul><li><p>方式一：继承于Thread类</p><ol type="1"><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run() -----&gt;将此线程执行的操作声明在run()方法中</li><li>创建Thread类的子类对象</li><li>通过此对象调用start()----&gt;启动当前线程，并调用当前线程的run()</li></ol><p>注意：</p><ul><li>不能通过直接调用run方法启动线程，这样不会新创建一个线程</li><li>不能让已经start()过的线程再次执行start()，需要重新创建一个线程对象</li><li>线程类也可以匿名调用</li><li><p>常用方法：</p><ul><li>start()：</li><li>run()：通常要重写Thread类中的此方法，将创建的线程要执行的操作声明在方法中</li><li>currentThread()：静态方法，返回执行当前代码的线程</li><li>getName()：获取当前线程的名字</li><li>setName()：设置当前线程的名字</li><li>yield()：释放当前CPU的执行权</li><li>join()：在线程a中调用线程b的join()，线程a就进入阻塞状态，直到线程b完全执行完毕 后，a才会 结束阻塞状态</li><li>stop()：强制结束当前线程（已过时，不推荐使用）</li><li>sleep()：静态方法，让当前线程强制阻塞指定的毫秒数，在此时间内，当前线程是阻塞状态</li><li>isAlive()：判断当前线程是否存活</li></ul></li></ul></li><li><p>方式二：实现Runnable接口</p><ol type="1"><li>创建一个实现了Runnable接口的类</li><li>实现类去实现Runnable中的抽象方法：run()</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()</li></ol></li><li><p>比较两种创建线程的方式：</p><ul><li><p>开发中优先选择Runnable接口的方式</p><p>原因：1. 实现的方式没有类的单继承的局限性；</p><pre><code>        2. 实现的方式更适合来处理多个线程有共享数据的情况</code></pre></li><li><p>Thread本身也实现了Runnable接口</p></li><li><p>两种方式都要重写run方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class Window implements Runnable</span></span><br><span class="line">Window w = <span class="keyword">new</span> Window();<span class="comment">//共享一个对象的数据</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程优先级">线程优先级</h3><ol type="1"><li><p>MAX_PRIORITY：10</p></li><li><p>MIN_PRIORITY：1</p></li><li><p>NORM_PRIORITY：5（默认优先级）</p></li><li><p>如何获取和设置当前线程的优先级</p><ul><li>getPriority()：获取线程优先级</li><li>setPriority(int p)：设置线程的优先级</li></ul><p>说明：高优先级的线程要抢占低优先级线程cpu的执行权，但是只是从概率上讲，高优先级的线程高概率的情况下被执行，并不意味着只有当高优先级线程执行完以后，低优先级的线程才执行。</p></li></ol><h3 id="线程的生命周期">线程的生命周期</h3><p><img src="https://static01.imgkr.com/temp/22a8b29943c249abb2231c075d503452.png" /></p><h3 id="线程安全问题">线程安全问题</h3><ul><li><p>Java中通常使用同步来解决线程安全问题</p></li><li><p>方式一：同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line"><span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>说明：1. 操作共享数据的代码，即为需要被同步的代码；--&gt;不能包含代码多了也不能包含少了</p><ol start="2" type="1"><li><p>共享数据：多个线程共同操作的变量，比如买票系统中的不同窗口共同操作的票数</p></li><li><p>同步监视器：俗称：“锁”，任何一个类的对象，都可以充当锁</p><p>要求：多个线程必须要共用同一把锁</p><p>补充：</p><ul><li>在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器</li><li>在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器</li></ul></li></ol><ul><li><p>方式二：同步方法</p><p>如果操作共享数据的代码完整地声明在一个方法中，我们不妨将此方法声明为同步的。</p></li><li><p>同步的方式，解决了线程的安全问题--好处</p><p>操作同步代码的同时，只能有一个线程参与，其他线程等待，相当于是一个单线程的过程，效率低--局限性</p></li><li><p>同步方法的总结：</p><ul><li>同步放那个发仍然涉及到同步监视器，只是不需要我们显式声明</li><li>非静态的同步方法，同步监视器是：this</li><li>静态的同步方法，同步监视器是：当前类本身</li></ul></li></ul><h3 id="死锁">死锁</h3><p>概念：</p><ul><li>不同线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁；</li><li>出现死锁后，不会出现异常和提示，只是所有的线程都处于阻塞状态，无法继续</li></ul><h3 id="lock锁">Lock锁</h3><p>解决线程安全的方式三：Lock锁 ---JDK5.0新增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="comment">//处理的代码</span></span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure><ul><li><p>问题：Lock和Synchronized的异同：</p><ul><li><p>相同：两者都可以解决线程安全问题</p></li><li><p>不同：</p><ul><li>synchronized机制在执行完相应的同步代码后，自动释放同步监视器</li></ul><p>​ Lock需要手动启动同步（lock()），同时结束同步也需要手动实现（unlock()）</p><ul><li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li><li>使用Lock锁。JVM将花费较少时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li></ul></li><li><p>优先使用顺序：Lock-&gt;同步代码块（已经进入方法体，分配了相应资源）-&gt;同步方法（方法体之外）</p></li></ul></li></ul><h3 id="线程通信案例">线程通信案例</h3><p>双线程交替打印1~100</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                notify();</span><br><span class="line">                <span class="keyword">if</span> (num &lt; <span class="number">100</span>)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + num++);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();<span class="comment">//wait方法会释放锁</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到的三个方法：</p><ul><li>wait()：一旦执行此方法，当前线程进入阻塞状态，并释放同步监视器</li><li>notify()：一旦执行此方法，就会唤醒被wait()的一个线程，如果有多个线程被wait，就唤醒优先级高的那个</li><li>notifyAll()：一旦执行此方法，就会唤醒所有被wait的线程</li></ul><p>说明：</p><ol type="1"><li>以上三个方法必须使用在同步代码块或同步方法中（lock中也不可以）</li><li>以上三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则会出现IllegalMonitorStateException异常</li><li>以上三个方法定义在Object类中</li></ol><p>问：sleep()和wait()的异同？</p><ol type="1"><li>相同：一旦执行方法，都可以使当前线程进入阻塞态</li><li>不同：<ol type="1"><li>两个方法声明的位置不同，Thread类中声明sleep()，Object类中声明wait()</li><li>调用的要求不同：sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块或同步方法中</li><li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁</li></ol></li></ol><h3 id="jdk5.0新增线程创建方式">JDK5.0新增线程创建方式</h3><ol type="1"><li><p>新增方式一：实现Callable接口</p><p>与Runnable相比，Callable功能更加强大：</p><ul><li>相比run()，call()可以有返回值</li><li>方法可以抛出异常</li><li>支持泛型的返回值</li><li>需要借助FutureTask类，比如获取返回结果</li></ul><p>注：Future接口</p><ul><li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等；</li><li>FutureTask是Future接口的唯一实现类</li><li>FutureTask同时实现了Runnable，Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*打印100以内偶数并求和*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CausualJav</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(myThread);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//get返回值为FutureTask构造器参数Callable实现类重写的call()的返回值</span></span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=<span class="number">100</span>;++i)</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                num+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol type="1"><li>创建一个实现Callable的实现类</li><li>实现call方法，将此线程需要执行的操作声明在call()中</li><li>创建Callable接口实现类的对象</li><li>将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask对象</li><li>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象并调用start()</li><li>获取Callable中call方法的返回值</li></ol><p>2.新增方式二：使用线程池</p><p>经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</p><p>因此提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建销毁、实现重复利用。</p><p>好处：</p><ul><li>提高响应速度，减少创建新线程的时间</li><li>降低资源消耗：重复利用线程池中的线程，不需要每次都创建</li><li>便于线程管理<ul><li>corePoolSize：核心池的大小</li><li>maximumPoolSize：最大线程数</li><li>keepAliveTime：线程没有任务时最多保持多长时间后终止</li><li>...</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class NumThread implements Runnable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//2.执行指定的线程操作，需要提供Runnable/Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumThread());<span class="comment">//适合使用Runnable</span></span><br><span class="line">        <span class="comment">//service.submit();//适合使用Callable</span></span><br><span class="line">        service.shutdown();<span class="comment">//线程池关闭操作</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java SE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础细节3-异常处理</title>
    <link href="/2021/05/10/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%823-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2021/05/10/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%823-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="概述">概述</h3><p>Java程序在执行过程中发生的异常事件分为两类：</p><ul><li>Error：Java虚拟机上无法解决的严重问题，如JVM内部错误，资源耗尽等严重情况，如StackOverflowError和OOM，一般不编写针对性的代码；</li><li>Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。如<ul><li>空指针访问</li><li>试图读取不存在的文件</li><li>网络连接中断</li><li>数组角标越界</li></ul></li></ul><p>java.lang.Trowable</p><p>​ |------java.lang.Error（unchecked）</p><p>​ |------java.lang.Exception</p><p>​ |------编译时异常（checked）</p><p>​ |------IOException</p><p>​ |------FileNotFoundException</p><p>​ |-------ClassNotFoundException</p><p>​ |------运行时异常（unchecked）</p><p>​ |------NullPointerException</p><p>​ |------ArrayIndexOutOfBoundsException</p><p>​ |------ClassCastException</p><p>​ |------NumberFormatException</p><p>​ |------InputMismatchException</p><p>​ |------ArithmaticException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//NullPointerException</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">null</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">    String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.println(s.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ClassCastException</span></span><br><span class="line">    Object o = <span class="keyword">new</span> Date();</span><br><span class="line">    String s = (String)o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//NumberFormatException</span></span><br><span class="line">    String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> num = Integer.parseInt(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//InputMismatchException</span></span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> score = scanner.nextInt();</span><br><span class="line">    System.out.println(score);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//ArithmeticException</span></span><br><span class="line">    System.out.println(<span class="number">10</span>/<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理机制">异常处理机制</h3><p>Java的异常处理机制，是将异常处理的代码集中在一起，与正常的程序代码分开，使得程序简洁优雅易于维护。</p><ol type="1"><li>抓抛模型<ol type="1"><li>“抛“：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。抛出对象后，其后的代码就不再执行。</li><li>“抓”：可以理解为异常的处理方式：<ol type="1"><li>try-catch-finallly；</li><li>throws；</li></ol></li></ol></li><li>异常处理的方式一：try-catch-finally<ul><li>finally是可选的；</li><li>使用try将可能出现的异常代码包起来，在执行过程中一旦出现异常，会生成一个对应异常的对象，根据对象的类型可以去catch中匹配；</li><li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理，一旦处理完成，就退出当前的try-catch结构（没有写finally的情况），继续执行其后的代码；</li><li>catch中的异常类型如果没有父子类关系，则声明的顺序无所谓；</li><li>catch中的异常类型如果满足父子类关系，则要求子类一定声明在父类上面，否则编译报错</li><li>常用的异常对象处理方式<ul><li>String getMessage()</li><li>void printStackTrace()</li></ul></li><li>try-catch-finally处理编译时异常，使程序在编译时不再报错，但是运行时仍可能报错；</li><li>finally中声明的是一定会被执行的代码，即使在catch中又出异常了，try中有return语句，catch中有return语句等情况下；</li><li>像数据库连接、输入输出流、网络编程Socket等资源。JVM是不能自动回收的，我们需要自己手动进行资源的释放，此时的资源释放，就需要声明在finally中;</li><li>try-catch-finally可以根据需要相互嵌套;</li><li>开发中由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了，针对编译时异常更多；</li></ul></li><li><p>异常处理的方式二：throws+异常类型</p><ul><li><p>throws+异常类型 写在方法的声明处，指明此方法执行时，可能会抛出的异常类型</p><p>一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出，异常代码后续的代码，就不再被执行；</p></li><li><p>体会：try-catch-finally：真正处理了异常</p><p>​ throws方式只是将异常抛给了方法的调用者，没有真正处理异常</p></li></ul></li></ol><h3 id="开发中选择异常处理方式的规则">开发中选择异常处理方式的规则</h3><ol type="1"><li>子类重写的方法抛出的异常类型不大于父类被重写方法抛出的异常类型</li><li>如果父类中被重写的方法没有throws处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理；</li><li>执行的方法a中，先后又调用了另外几个方法，这几个方法是递进关系执行的，我们建议这几个方法使用throws的方式进行处理，而执行的方法a可以考虑使用try-catch-finally方式进行处理。</li></ol><h3 id="手动抛出异常自定义异常类">手动抛出异常&amp;自定义异常类</h3><p>异常对象的产生：</p><ul><li>系统自动生成的异常对象</li><li>手动生成的一个异常对象，并throw</li></ul><p>自定义异常类：</p><ul><li>继承与现有的异常结构：RuntimeException、Exception</li><li>提供全局常量：serialVersionUID</li><li>提供重载的构造器</li></ul><h3 id="总结">总结</h3><p>五个关键字：try，catch，finally，throws，throw</p><ul><li>try：执行可能产生异常的代码</li><li>catch：捕获异常</li><li>finally：无论是否发生异常，代码总被执行</li><li>throws：异常的处理方式：声明方法可能要抛出的各种异常类</li><li>throw：异常的生成阶段：手动抛出异常对象</li></ul><p>编译时异常：执行javac.exe命令时，可能出现的异常</p><p>运行时异常：执行java.exe命令时，出现的异常</p><h3 id="case">Case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CausualJav</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> j = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">            result = ecm(i,j);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EcDef ecDef) &#123;</span><br><span class="line">            System.out.println(ecDef.getMessage());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ecm</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> <span class="keyword">throws</span> EcDef </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EcDef(<span class="string">&quot;负数异常哦&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i/j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EcDef</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3387500000004229948L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EcDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EcDef</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java SE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础细节2-类与对象</title>
    <link href="/2021/05/08/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%822-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/05/08/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%822-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="类与对象的三条主线">类与对象的三条主线</h3><p>类的成员：属性、方法、构造器、代码块、内部类</p><p>关键字：static，final, abstract</p><p>接口</p><h3 id="方法的重载和重写">方法的重载和重写</h3><ul><li><p>重载Overload</p><p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或参数类型不同即可。</p><p>两同一不同：同一个类，同一个方法名，参数列表不同，参数个数不同，参数类型不同</p><p>判断是否是重载：跟方法的权限修饰符、返回类型值、形参变量名、方法体都没有关系！</p><p>注：相同参数位置不同，参数列表也不同。</p></li><li><p>重写Override</p><p>子类继承父类后，可以对父类中同名同参数的方法进行覆盖操作。</p><ul><li>子类重写的方法权限修饰符不小于父类被重写方法的权限修饰符；<ul><li>特殊情况：子类不能重写父类中声明为private权限的方法；</li></ul></li><li>返回值类型：<ul><li>父类被重写方法的返回值类型是void，则子类重写方法的返回值类型只能是void；</li><li>父类被重写方法的返回值类型是A类型，则子类重写方法的返回值类型可以是A或A的子类；</li><li>父类被重写方法的返回值类型是基本数据类型，则子类重写的方法返回值必须是相同的基本数据类型；</li></ul></li><li>子类重写的方法throws出的异常类型不大于父类被重写的方法抛出的异常类型；</li><li>子类和父类中的同名同参数方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）。</li></ul></li></ul><p>从编译和运行的角度看，</p><ul><li>对于重载，编译器根据方法不同的参数表，对同名方法的名称做修饰，对于编译器来说，这些同名方法就成了不同的方法，它们的调用地址在编译期就确定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法；</li><li>对于重载，方法调用之前编译器就确定了要调用的方法，这称为“早绑定”或“静态绑定”；</li><li>对于多态，只有等到方法调用的那一刻，编译器才会确定要调用的具体方法，这称为“晚绑定”或“动态绑定”。</li></ul><h3 id="类的构造器">类的构造器</h3><ul><li>构造器用于创建类对象，初始化对象结构，构造器没有返回值，可以用权限修饰符修饰；</li><li>任何类都有构造器；</li><li>一旦显示定义了类的构造器后，系统就不再提供默认的空构造器；</li><li>通过子类的构造器创建子类对象时，会直接或间接调用父类的构造器，进而调用父类的父类的构造器，直到调用了Object类中空参的构造器为止，正因为加载过所有的父类结构，才能在内存中看到父类的结构。（但只创造了一个子类对象）</li></ul><h3 id="面向对象的三大特性">面向对象的三大特性</h3><h5 id="类的封装性体现">类的封装性体现：</h5><ol type="1"><li>类的属性xxx私化private，同时提供公共的public方法来获取get和设置set属性的值；</li><li>不对外暴露的私有的方法；</li><li>单例模式（将构造器私有化）；</li><li>如果不希望类在包外被调用，可以将类设置为缺省的。</li></ol><p>Java四种权限修饰符： private，缺省，protected，public</p><p>四种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类，修饰类的话只能使用：缺省，public；</p><table><thead><tr class="header"><th>修饰符</th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th>同一个工程</th></tr></thead><tbody><tr class="odd"><td>private</td><td>yes</td><td></td><td></td><td></td></tr><tr class="even"><td>缺省</td><td>yes</td><td>yes</td><td></td><td></td></tr><tr class="odd"><td>protected</td><td>yes</td><td>yes</td><td>yes</td><td></td></tr><tr class="even"><td>public</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table><h5 id="类的继承性">类的继承性：</h5><p>体现：子类A继承父类B后，子类A中就获取了B中声明的所有属性和方法，特别的，父类中的private属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构，只是因为封装性的影响，使得子类不能直接调用父类的结构而已；</p><p>特点：</p><ol type="1"><li>一个类可以被多个子类继承，但一个类智能有一个父类；</li><li>直接继承的父类：直接父类，间接继承的父类：间接父类；</li></ol><h5 id="类的多态性">类的多态性：</h5><ul><li>虚拟方法调用（多态）：</li></ul><p>子类中定义了与父类同名同参数的方法，在多态情况下，此时的父类方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法，这样的方法调用在编译期是无法确定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person e = <span class="keyword">new</span> Student();</span><br><span class="line">e.getInfo();<span class="comment">//调用Student类的getInfo()方法</span></span><br></pre></td></tr></table></figure><ul><li><p>编译时类型和运行时类型：</p><p>编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo()方法。称为：<strong><u>动态绑定</u></strong>。</p></li></ul><p>注意：对象的多态性只适用于方法，不适用于属性，编译和运行都看声明的变量（左边）。</p><ul><li><p>向上和向下转型：</p><ul><li><p>向上转型：多态</p></li><li><p>向下转型：强制类型转换符</p><p>有了对象的多态后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法，而不能调用子类特有的属性和方法。</p></li></ul></li></ul><h3 id="static">static</h3><ol type="1"><li>static可以用来修饰：属性、方法、代码块、内部类；</li><li>修饰属性：静态变量（对比于实例变量）</li><li>静态变量：随着类加载而被加载，早于对象创建；</li><li>静态变量在内存中只存在一份，在方法区的静态域中；</li><li>静态方法：静态方法中只能调用静态方法和属性，非静态方法中可以调用静态方法和属性，也可以调用非静态方法和属性；</li><li>注意：静态方法中不能使用this，super关键字；</li><li>开发中：<ul><li>为多个对象共享的，不会随着对象不同而不同的属性一般声明为static；</li><li>操作静态属性的方法，以及工具类中的方法，一般声明为static；</li></ul></li><li>静态方法不能被重写。</li></ol><h3 id="单例设计模式">单例设计模式</h3><p>单例设计模式，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例。</p><p>实现方式: 饿汉式：对象加载时间长，线程安全（预先创建好对象）；</p><p>​ 懒汉式：延迟对象的创建，线程不安全（用的时候再创建对象）。</p><h3 id="代码块">代码块</h3><p>作用：初始化类，对象</p><p>代码块如果有修饰的话只能用static，可以分为静态和非静态代码块</p><p>注：创建对象时代码块的运行顺序：首先加载父子类，此时会由父及子先依次运行静态的代码块，， 接着创建子类对象时，先依次调用父类的代码块和构造器，也是由父及子，层层向下到对象类。</p><ul><li>静态代码块：<ul><li>内部可以有输出语句</li><li>随着类加载而执行，只执行一次</li><li>作用为初始化类的信息</li><li>若一个类中定义了多个静态代码块，则按照声明的先后顺序执行</li><li>静态代码块的执行要优先于非静态代码块的执行</li><li>静态代码块内只能调用静态的属性、方法，不能调用非静态的结构</li></ul></li><li>非静态代码块：<ul><li>内部可以有输出语句</li><li>随着对象的创建而执行</li><li>每创建一个对象，就执行一次非静态代码块</li><li>作用是可以在创建对象时，对对象的属性进行初始化</li><li>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</li><li>非静态的代码块可以调用静态或非静态的结构</li></ul></li></ul><h3 id="对属性赋值的顺序">对属性赋值的顺序：</h3><ul><li><p>默认初始化</p></li><li><p>显式初始化、代码块中赋值（根据两者位置判断先后顺序）</p></li><li><p>构造器中初始化</p></li><li><p>有了对象以后，通过对象.属性或对象.方法的方式赋值</p></li></ul><h3 id="final">final</h3><ol type="1"><li>final可以用来修饰：类、方法、变量（属性是变量的一种）</li><li>final修饰的类不能被其他类继承，final修饰的方法不能被重写，</li><li>final修饰的变量称为一个常量：<ol type="1"><li>final修饰属性，可以赋值的位置有：显式初始化、代码块中初始化、构造器中初始化</li><li>final修饰局部变量：final可以修饰形参，表明此形参是一个常量，调用该方法时给常量形参赋一个实参，在方法中只能使用该参数，不能修改</li></ol></li><li>static final：用来修饰属性：<strong><span class="math inline">\(\textcolor{red}{全局常量}\)</span></strong></li></ol><h3 id="abstract抽象类和抽象方法">Abstract：抽象类和抽象方法</h3><ol type="1"><li><p>abstract可以用来修饰: 类、方法</p></li><li><p>abstract修饰类：抽象类</p><ul><li>此类不能实例化</li><li>抽象类中依然有构造器，方便子类实例化时调用</li><li>开发中，都会提供抽象类的子类，让子类对象实例化</li></ul></li><li><p>abstract修饰方法：抽象方法</p><ul><li><p>抽象方法只有方法的声明，没有方法体</p></li><li><p>包含抽象方法的类，一定是个抽象类，反之不一定成立</p></li><li><p>子类重写父类中的所有抽象方法后，次子类方可实例化，</p><p>若子类没有重写父类的所有抽象方法，则此子类仍然是抽象类</p></li></ul></li><li><p>注意点：</p><ol type="1"><li>abstract不能修饰：属性、构造器等结构</li><li>abstract不能修饰：私有方法、静态方法、final的方法、final的类</li><li>可以实现匿名子类的（非匿名）对象</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">Animal p = <span class="keyword">new</span> Animal() &#123;<span class="comment">//实例化匿名子类的匿名对象</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//重写抽象类Animal</span></span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><pre><code>5.  抽象类的应用：模板模式6.  抽象类可以继承非抽象类（如Object）</code></pre><h3 id="interface接口">Interface:接口</h3><ol type="1"><li>Java中接口和类是并列的两个结构；</li><li>如何定义接口，定义接口中的成员：<ol type="1"><li>JDK7及以前，只能定义全局常量和抽象方法<ul><li>全局常量：public static final，但是书写时，可以省略不写，可以通过接口.变量去访问</li><li>抽象方法：public abstract</li></ul></li><li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）</li></ol></li><li>接口中不能定义构造器！意味着接口不可以实例化</li><li>Java开发中个，接口通过让类去实现（implements）的方式来使用，<ul><li>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化；</li><li>如果实现类没有覆盖接口中的所有抽象方法，则此实现类仍为一个抽象类。</li></ul></li><li>Java类可以实现多个接口：弥补了Java单继承的局限性。</li><li>接口和接口之间可以继承，而且可以多继承；</li><li>与继承关系类似，接口与实现类之间存在多态性；</li><li>接口可以理解为一种特殊的类，本质上接口是一种特殊的抽象类，这种抽象类中只包含常量和方法定义（JDK7.0之前），而没有变量和方法的实现；</li><li>接口可以实现匿名实现类的对象。</li></ol><ul><li><p>应用： Proxy代理设计模式：为其他对象提供一种代理以控制对这个对象的访问。</p><p>​ 工厂模式</p></li></ul><p>注意：若一个类继承的父类和实现的接口中有重名变量的初始化，会报错，因为变量不明确</p><h3 id="java8的接口新特性">Java8的接口新特性</h3><ol type="1"><li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</li><li>接口中定义的静态方法，只能通过接口来调用</li><li>通过实现类的对象，可以调用接口中的默认方法，如果实现类重写了默认方法，调用时仍然调用的是重写以后的方法</li><li>如果子类（实现类）继承的父类和实现的接口中声明了同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法（<span class="math inline">\(\textcolor{red}{类优先原则}\)</span>）</li><li>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类中没有重写此方法的情况下，会报错（<span class="math inline">\(\textcolor{red}{接口冲突}\)</span>），此时需要我们必须在实现类中重写此方法</li><li>如何在子类（实现类）方法中调用父类、接口中被重写的方法？</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span> <span class="keyword">extends</span> <span class="title">AbA</span> <span class="keyword">implements</span> <span class="title">ComparableA</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        method2();<span class="comment">//调用本类重写的方法</span></span><br><span class="line">        <span class="keyword">super</span>.method2();<span class="comment">//调用父类中的同名方法</span></span><br><span class="line">        ComparableA.<span class="keyword">super</span>.method2();<span class="comment">//调用实现接口中的同名方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类">内部类</h3><ol type="1"><li><p>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</p></li><li><p>内部类的分类：成员内部类VS局部内部类（方法内、代码块内、构造器内）</p></li><li><p>成员内部类：一方面，作为外部类的成员：调用外部类结构</p><p>​ 可以用static修饰</p><p>​ 可以被四种不同权限修饰</p><p>​ 另一方面，作为一个类：类内可已定义属性、方法、构造器</p><p>​ 可以被final修饰，表示此类不能被继承</p><p>​ 可以被abstract修饰</p></li><li><p>如何实例化成员内部类的对象？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.Akash akash = <span class="keyword">new</span> Person.Akash();        <span class="comment">//实例化静态成员内部类</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person.Brain brain = p.<span class="function">new <span class="title">Brain</span><span class="params">()</span></span>;             <span class="comment">//实例化非静态成员内部类</span></span><br></pre></td></tr></table></figure></li><li><p>如何在成员内部类中区分调用外部类的结构？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Brain</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">            System.out.println(Person.<span class="keyword">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开发中局部内部类的使用</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareTest</span></span>&#123;<span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyComparable</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;<span class="comment">//创建一个实现了Comparable接口的局部内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyComparable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareTest</span> </span>&#123;<span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Comparable() &#123;   <span class="comment">//也可以直接返回匿名类的匿名对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7" type="1"><li>局部内部类的方法中，如果调用外部类所声明的方法中的局部变量，要求此局部变量为final（jdk7及之前要求此局部变量显式声明final，8之后可省略）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java SE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础细节1</title>
    <link href="/2021/05/06/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%821/"/>
    <url>/2021/05/06/Java%E5%9F%BA%E7%A1%80%E7%BB%86%E8%8A%821/</url>
    
    <content type="html"><![CDATA[<h3 id="自动类型转换">自动类型转换</h3><ol type="1"><li>byte -- short -- int -- long -- float -- double</li></ol><p>char -- int -- long -- float -- double</p><p>（byte，short）和char之间不能进行类型转换</p><ol start="2" type="1"><li><p>多种类型数据混合运算时，系统先自动将所有数据转换成容量最大的那种数据类型，然后计算；</p></li><li><p>精度（容量）大的数据类型赋值给精度（容量）小的数据类型时，就会报错，反之会自动进行类型转换；</p></li><li><p>当将一个具体数值赋给一种数据类型时，会先判断该数是否在该数据类型范围内，若不在会直接报错，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">128</span>;    <span class="comment">// 超出范围，报错</span></span><br></pre></td></tr></table></figure></li><li><p>byte，short，char三者可以进行计算，含有其中任一类型进行计算时，结果首先转换为int类型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = b1 + b2;<span class="comment">//int值赋给byte类型，报错</span></span><br><span class="line">b1++;</span><br><span class="line">b1 += <span class="number">2</span>;<span class="comment">//成立，因为复合运算符可视为包含强制类型转换</span></span><br></pre></td></tr></table></figure></li><li><p>boolean类型不参与类型转换；</p></li></ol><h3 id="强制类型转换">强制类型转换</h3><ol type="1"><li>当进行数据的大小从大--&gt;小，就需要使用强制转换；</li><li>强制转换符号只对最近的操作数有效，往往使用小括号提升优先级；</li><li>char类型可以保存int类型的常量值，但不能保存int类型的变量值，需要强转；</li><li>byte，short和char类型在进行运算时，当做int类型处理；</li></ol><h3 id="基本数据类型和stirng类型">基本数据类型和Stirng类型</h3><ol type="1"><li>基本数据类型转String： 基本数据类型+“ ”；</li><li>String转基本数据类型：使用基本数据类型对应的包装类的相应的parse方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = Integer.parseInt(s1);</span><br><span class="line"><span class="keyword">double</span> num2 = Double.parseDouble(s2);</span><br></pre></td></tr></table></figure><p>==注：String转char时通常指取出String中的第一个char==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = s.charAt(<span class="number">0</span>)<span class="comment">//得到字符串s的第一个字符</span></span><br></pre></td></tr></table></figure><p>注意事项：转换须有意义，格式要正确，否则会抛出异常。</p><h3 id="原码反码补码">原码、反码、补码</h3><ol type="1"><li>二进制的最高位是符号位：0表示正数，1表示负数；</li><li>正数三码合一：原码、反码和补码都一样；</li><li>负数的反码 = 它的原码符号位不变，其他位取反；</li><li>负数的补码 = 它的反码+1， 负数的反码 = 它的补码 -1；</li><li>0的反码补码都是0；</li><li>java没有无符号数，换言之，java中的数都是有符号的；</li><li>计算机运算过程中都是以补码方式来运算的；</li><li>我们看运算结果时要看它的原码。</li></ol><h3 id="数组">数组</h3><ol type="1"><li>数组是多个相同类型数据的组合，实现对这些数据的统一管理；</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用；</li><li>数组创建后如果没有赋值，对于不同类型有默认值；</li><li>使用数组的步骤：声明数组，开辟空间，给各元素赋值，使用数组；</li><li>数组下标从0开始；</li><li>数组属于引用类型，数组型数据是对象（Object）；</li><li>基本数据类型赋值方式为值拷贝，数组默认情况下是引用传递，赋的值是地址，赋值方式为引用赋值；</li></ol><h3 id="关键字与保留字">关键字与保留字</h3><p>关键字：小写，Java赋予了特殊含义，用于专门用途的字符串</p><ul><li>用于定义数据类型：class，interface，enum，byte，short，int，long，float，double，char，boolean，void；</li><li>用于定义流程控制：if，else，switch，case，default，while，do，for，break，countinue，return；</li><li>用于定义访问权限修饰符：private，protected，public；</li><li>用于定义类，函数，变量修饰符：abstract，final，static，sychronized；</li><li>用于定义类之间关系：extends，implements；</li><li>用于定义建立实例及引用实例，判断实例：new，this，super，instanceof；</li><li>用于异常处理：try，catch，finally，throw，throws；</li><li>用于包：import，package；</li><li>其他修饰符关键字：native，strictfp，transient，volatile，assert；</li><li><em>用于定义数据类型值的字面值：true，false，null；</em>（严格来说不算关键字）</li></ul><p>保留字：现有Java版本尚未使用，以后版本可能作为关键字使用；</p><p>​ goto，const</p><h3 id="对象创建和使用内存解析">对象创建和使用：内存解析</h3><ul><li>堆Heap：此内存区域的唯一目的是存放对象实例。所有的对象实例以及数组都要在堆上分配；</li><li>栈Stack：虚拟机栈用于存储局部变量等，局部变量表存放了编译期可知长度的各种基本数据类型、对象引用（存放对象在堆内存的首地址）。方法执行完，自动释放；</li><li>方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li></ul><h3 id="参数传递值传递与引用传递">参数传递：值传递与引用传递</h3><h5 id="变量赋值规则">变量赋值规则：</h5><ul><li>如果变量是基本数据类型，此时赋值的是变量所保存的数据值；</li><li>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值；</li></ul><h5 id="方法的形参传递机制">方法的形参传递机制：</h5><ul><li>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值；</li><li>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java SE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架专题2-Map</title>
    <link href="/2021/05/04/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%93%E9%A2%982-Map/"/>
    <url>/2021/05/04/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%93%E9%A2%982-Map/</url>
    
    <content type="html"><![CDATA[<h3 id="map接口特点常用方法">1. Map接口特点&amp;常用方法</h3><ol type="1"><li>Map与Collection并列，用于存储有映射关系的元素k-v；</li><li>Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中；</li><li>Map中的key不允许重复，put相同的key等价于替换；</li><li>Map中value可以重复；</li><li>Map中key和value都可以为null，但是key只有一个为null，value可以有多个；</li><li>常用Stirng类作为key，实际上key为Object；</li><li>key和value之间为单向一对一对应关系，总可以通过一个key找到对应的value；</li><li>一对k-v存储在HashMap$Node对象中， Node实现了Entry接口，因此一对k-v即是一个Entry；<ul><li>k-v为了方便遍历，会创建EntrySet集合，该集合存放的元素类型Entry；</li><li>EntrySet中定义的类型是Map.Entry，但实际上存放的还是HashMap$Node，因为HashMap$Node实现了Map.Entry接口；</li><li>当把HashMap$Node对象存放到EntrySet就方便我们的遍历，因为Map.Entry类提供了重要方法：K getKey(); V getValue();</li></ul></li></ol><p>常用方法：put(), remove(), get(), size(), isEmpty(), clear(), containsKey()</p><p>遍历方法：</p><ol type="1"><li>用keySet()取出所有Key(数据类型为Set)，通过Key取出对应的Value</li><li>用values()取出所有values(数据类型为Collection)；</li><li>用EntrySet来获取k-v；</li></ol><p>HashMap和HashSet一样，不保证映射顺序，也没有实现同步，是线程不安全的。</p><h3 id="hashmap">2. HashMap</h3><p>table数组中放置一个个Node，包含一对(k,v)，Node实现了Map.Entry&lt;k,v&gt;</p><ol type="1"><li>HashMap底层维护Node类型数组table，默认为null；</li><li>创建对象时，加载因子初始化为0.75；</li><li>添加key-val时，通过key的哈希值得到在table中的索引，然后判断索引处是否有元素，没有则直接添加，有元素则继续判断该元素的key和准备加入的key是否相等（对象相同或equals()为真），若相等，则直接替换val；如果不相等则根据树或链表结构的不同做出相应处理。若添加时容量不够则进行扩容；</li><li>第一次添加扩容table为16，临界值treshhold为16*0.75 = 12;</li><li>后续扩容将table扩充为原来的两倍，即32，临界值为24，以此类推；</li><li>Java8中，链表元素个数超过树化临界值（默认8）且table大小大于等于最小树化容量（默认64）,链表将会树化（红黑树）。</li></ol><h3 id="hashtable">3. HashTable</h3><ul><li>HashTable存放键值对k-v，继承Dictionary；</li><li>HashTable的键值都不能为null，否则抛出NullPointerException；</li><li>HashTable使用方法基本上和HashMap一样；</li><li>HashTable是线程安全的，HashMap不是；</li></ul><p>底层实现：</p><ol type="1"><li>HashTable底层为数组Hashtable$Entry[]，初始化大小为11，存储Entry对象；</li><li>临界值为8 = 11*0.75；</li><li>扩容：达到临界值后按容量*2+1进行扩容；</li><li>执行方法addEntry()，添加k-v封装到Entry；</li></ol><h3 id="properties">4. Properties</h3><p>Properties类继承自HashTable类并实现了Map接口，也是通过键值对形式来保存数据，使用特点和HashTable类似。可以通过k-v存放数据，key和value不能为null；</p><p>注：properties可用于从xxx.properties文件(通常为配置文件)中加载数据到Properties类对象并进行读取和修改</p><h3 id="开发中如何选择集合实现类">5. 开发中如何选择集合实现类</h3><ol type="1"><li>首先确定存储的类型（一组对象或一组键值对，即单列&amp;双列）；</li><li>一组对象【单列】：Collection<ol type="1"><li>允许重复：List<ol type="1"><li>增删多：LinkedList【底层维护了一个双向链表】；</li><li>改查多：ArrayList【底层维护Object类型的可变数组】；</li></ol></li><li>不允许重复：Set<ol type="1"><li>无序：HashSet【底层是HashMap，维护了一个Hash表【数组+链表+红黑树】】;</li><li>排序TreeSet</li><li>插入和取出顺序一致LinkedHashSet（底层LinkedHashMap的底层是HashMap），维护数组+双向链表</li></ol></li><li>一组键值对：Map<ol type="1"><li>键无序：HashMap【底层是：Hash表 jdk8：数组+链表+红黑树】；</li><li>键排序：TreeMap；</li><li>键插入和取出顺序一致：LinkedHashMap；</li><li>读取文件：Properties</li></ol></li></ol></li></ol><h3 id="treeset">6. TreeSet</h3><ol type="1"><li><p>TreeSet底层是TreeMap；</p></li><li><p>若使用无参构造器初始化TreeSet，会无序；</p></li><li><p>若使用TreeSet提供的一个构造器，可以以lamda表达式的方式传入一个比较器（匿名内部类），并指定排序规则；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeSet treeSet = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ((String)o1).compareTo((String)o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="treemap">7. TreeMap</h3><h3 id="collection工具类">8. Collection工具类</h3><p>Collection工具类是一个操作Set、List和Map等集合的工具类</p><p>Collection中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</p><p>排序操作：</p><ul><li>reverse(List): 翻转List中元素的顺序；</li><li>shuffle(List):对List集合元素进行随机排序；</li><li>sort(List):根据元素的自然顺序对指定List集合元素按升序排列；</li><li>sort(List，Comparator):根据指定的Comparator产生的顺序对List集合进行排序；</li></ul><p>查找替换：</p><ul><li>Object max(Collection):根据数组的自然顺序，返回给定集合中的最大元素；</li><li>Object max(Collection, Comparator): 根据Comparator指定的顺序，返回给定集合中的最大元素；</li><li>Object min(Collection);</li><li>Object min(Collection, Comparator);</li><li>int frequency(Collection, Object): 返回指定集合中指定元素的出现次数；</li><li>void copy(List dest, List src): 将src中的内容复制到dest中；</li><li>boolean replaceAll(List list, Object oldVal, Object newVal): 使用新值替换List对象的所有旧值；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>集合</tag>
      
      <tag>框架</tag>
      
      <tag>Map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架专题1-Collection</title>
    <link href="/2021/05/02/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%93%E9%A2%981-Collection/"/>
    <url>/2021/05/02/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%93%E9%A2%981-Collection/</url>
    
    <content type="html"><![CDATA[<h3 id="集合主要分为单列集合双列集合">1. 集合主要分为：单列集合、双列集合</h3><h3 id="collection单列集合--实现iterable接口">2. Collection：（单列集合）--&gt;实现Iterable接口</h3><ul><li>List<ul><li>Vector</li><li>ArrayList</li><li>LinkedList</li></ul></li><li>Set<ul><li>TreeSet</li><li>HashSet</li></ul></li></ul><h3 id="map双列集合k-v">Map：（双列集合k-v）</h3><ul><li><p>HashMap</p><ul><li>LinkedHashMap</li></ul></li><li><p>TreeMap</p></li><li><p>HashTable</p><ul><li>Properties</li></ul></li></ul><h3 id="collection-接口常用方法">3. Collection 接口常用方法</h3><p>add(), remove(), contains(), size(), isEmpty(), clear(), addAll(), containsAll(), removeAll()</p><p>Collection遍历元素方式:</p><ul><li>Iterator()迭代器生成Iterator对象：有hasNext()和next()</li><li>增强for循环：本质上仍然是迭代器实现</li></ul><h3 id="list接口常用方法">4. List接口&amp;常用方法</h3><ul><li>List集合勒种元素有序（添加和取出顺序一致）且可重复；</li><li>List容器中每个元素都有索引，从0开始</li></ul><p>常用方法：</p><p>add(), addAll(), get(), indexOf()第一次出现, lastIndexOf()末次出现, remove(), set()替换，subList()参数为两个下标，前闭后开截取出子串</p><p>List遍历元素方式: Iterator，增强for， 普通for</p><h3 id="arraylist底层结构源码分析">5. ArrayList底层结构&amp;源码分析</h3><ul><li>ArrayList注意事项：<ul><li>可以将null作为元素添加</li><li>由数组实现，基本等同Vector</li><li>线程不安全，无synchronized，多线程不建议使用, 但是效率较高</li></ul></li><li><p>底层机制</p><ul><li><p>ArrayList中维护了一个Object类型的数组elementData，transient Objet[] elementData,</p><p>transient表示不被序列化</p></li><li><p>创建ArrayList对象时，</p><ul><li>若使用无参构造器，则elementData容量变化：0-&gt;10-&gt;1.5倍</li><li>若使用指定大小的构造器，则elementDtaa容量变化：指定大小-&gt;1.5倍</li></ul></li></ul></li></ul><h3 id="vector底层源码分析">6. Vector底层源码分析</h3><p>Vector底层也是一个对象数组，不同于ArrayList的是，Vector是线程安全的，效率较低。</p><p>底层机制</p><ul><li><p>Vector中维护了一个Object类型的数组elementData，transient Objet[] elementData,</p><p>transient表示不被序列化</p></li><li><p>创建Vector对象时，</p><ul><li>若使用无参构造器，则elementData容量变化：0-&gt;10-&gt;2倍</li><li>若使用指定大小的构造器，则elementDtaa容量变化：指定大小-&gt;2倍</li></ul></li></ul><h3 id="linkedlist底层结构分析">7. LinkedList底层结构分析</h3><p>LinkedList底层实现了双向链表和双端队列的特点， 可以添加null在内的任意重复元素，线程不安全。</p><p>操作机制：</p><ul><li>LinkedList底层维护了一个双向链表；</li><li>LinkedList维护了两个属性：first和last分别指向首节点和尾节点；</li><li>每个Node对象都维护了prev，next和item三个属性；</li></ul><h3 id="set接口方法">8. Set接口方法</h3><ul><li>Set接口对象不能存放重复元素，可以存放一个null</li><li>Set接口对象存放数据是无序的，即添加和取出元素的顺序不一致</li><li>注意：Set取出元素的顺序是固定的，有特定算法</li></ul><p>遍历方式： 迭代器&amp;增强for循环（没有索引因此无法使用普通for循环）</p><h3 id="hashset底层结构源码">9. HashSet底层结构&amp;源码</h3><ul><li><p>HashSet底层是HashMap，HashMap底层是数组+链表+红黑树（数组元素为链表或红黑树）</p><p>其底层也为k-v键值对，但其v为常量，只使用k值</p></li></ul><p>底层机制（添加元素）：</p><ol type="1"><li>HashSet添加元素，先得到hash值，将其转化为索引值；</li><li>找到存储数据表table，看到该索引位置是否已经存放有元素；</li><li>若没有元素，直接加入；</li><li>若有元素，调用equals()比较，如果相同，放弃添加，如果不相同，则添加到最后；</li></ol><p>HashSet的扩容和转成红黑树机制：</p><ol type="1"><li><p>HashSet底层为HashMap，第一次添加时，table数组扩容到16，临界值（Treshhold）为16*加载因子（loadFactor = 0.75），即12；</p></li><li><p>若table数组使用了到了临界值12（由源码决定，可以包括链表中元素），就会扩容到16*2=32，新的临界值为32*0.75=24，以此类推；</p></li><li><p>Java8中，若数据表的链表元素个数超过TREEIFY_THRESHOLD(默认为8)，且table大小&gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化（红黑树）。（若链表元素到达8个，table大小小于64，则table进行2倍扩容。）</p></li></ol><h3 id="linkedhashset底层结构源码">10. LinkedHashSet底层结构&amp;源码</h3><ol type="1"><li><p>LinkedHashSet中维护了一个hash表和双向链表；(底层是LinkedHashMap)</p></li><li><p>每一个节点有pre和next属性，可以形成双向链表；</p></li><li><p>添加一个元素时，先求hash值，再求索引，确定元素在hashtable的位置，然后将添加的元素加入到双向链表（如已存在，不添加）；</p><p>tail.next = newElement;</p><p>newElement.pre = tail;</p><p>tail = newElement;</p></li><li><p>这样，遍历LinkedHashSet也能确保插入顺序和遍历顺序一致；</p></li></ol><p><strong><u>LinkedHashSet将一整条双向链表用索引分成几段。</u></strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>集合</tag>
      
      <tag>框架</tag>
      
      <tag>Collection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown First</title>
    <link href="/2021/05/02/Markdown-First/"/>
    <url>/2021/05/02/Markdown-First/</url>
    
    <content type="html"><![CDATA[<h3 id="级标题">1~6级标题</h3><h1 id="级-ctrl1">1级 Ctrl+1</h1><h2 id="级-ctrl2">2级 Ctrl+2</h2><h3 id="级-ctrl3">3级 Ctrl+3</h3><h4 id="级-ctrl4">4级 Ctrl+4</h4><h5 id="级-ctrl5">5级 Ctrl+5</h5><h6 id="级-ctrl6">6级 Ctrl+6</h6><p>增大标题级别 Ctrl+<strong>+</strong></p><p>减小标题级别 Ctrl+<strong>-</strong></p><p>将光标所在标题设置为正文 Ctrl+0</p><h3 id="插入表格-ctrlt">插入表格 Ctrl+T</h3><table><thead><tr class="header"><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr class="odd"><td>6</td><td>1</td><td>8</td></tr><tr class="even"><td>7</td><td>5</td><td>3</td></tr><tr class="odd"><td>2</td><td>9</td><td>4</td></tr></tbody></table><p>Alt+方向键 调整行位置</p><p>Ctrl+Shift+Backspace 删除行</p><p>Ctrl+Enter 下方插入行</p><h3 id="代码块">代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure><p>Ctrl+Shift+K</p><h3 id="公式块">公式块</h3><p><span class="math display">\[S_{tri} = \sqrt{p(p-a)(p-b)(p-c)} \qquad while\ p = (a+b+c)/2\]</span></p><p>Ctrl+Shift+M</p><h3 id="引用">引用</h3><blockquote><p>多年以后，奥雷连诺上校站在行刑队面前，准会想起父亲带他去参观冰块的那个遥远的下午。</p></blockquote><p>Ctrl+Shift+Q</p><h3 id="有序及无序列表">有序及无序列表</h3><ol type="1"><li><p>子</p></li><li><p>丑</p></li><li><p>寅</p></li><li><p>卯</p><p>有序列表 Ctrl+Shift+[</p></li></ol><ul><li><p>边a</p></li><li><p>边b</p></li><li><p>边c</p><p>无序列表 Ctrl+Shift+]</p></li></ul><h3 id="格式变化">格式变化</h3><table><thead><tr class="header"><th style="text-align: center;">功能</th><th style="text-align: center;">快捷键</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">粗体</td><td style="text-align: center;"><strong>Ctrl+B</strong></td></tr><tr class="even"><td style="text-align: center;">斜体</td><td style="text-align: center;"><em>Ctrl+I</em></td></tr><tr class="odd"><td style="text-align: center;">下划线</td><td style="text-align: center;"><u>Ctrl+U</u></td></tr><tr class="even"><td style="text-align: center;">行内代码</td><td style="text-align: center;">Ctrl+Shift+`</td></tr><tr class="odd"><td style="text-align: center;">删除线</td><td style="text-align: center;">Alt+Shift+5（<del>content</del>）</td></tr><tr class="even"><td style="text-align: center;">超链接</td><td style="text-align: center;">Ctrl+K （<a href="www.baidu.com">REF</a>）</td></tr><tr class="odd"><td style="text-align: center;">插入图片</td><td style="text-align: center;">Ctrl+Shift+I <embed src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fitem%2F201807%2F31%2F20180731224044_YYwmw.thumb.700_0.gif&amp;refer=http%3A%2F%2Fc-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1622518014&amp;t=24bfc901cf3243b67c2bf6393ce86977" /></td></tr><tr class="even"><td style="text-align: center;">清除样式</td><td style="text-align: center;">Ctrl+\</td></tr><tr class="odd"><td style="text-align: center;">源码模式</td><td style="text-align: center;">Ctrl+/</td></tr></tbody></table><h4 id="扩展语法">扩展语法</h4><table><thead><tr class="header"><th>功能</th><th>快捷键</th></tr></thead><tbody><tr class="odd"><td>上标</td><td>x<sup>2</sup> 左右^闭合</td></tr><tr class="even"><td>下标</td><td>H<sub>2</sub>O 左右~闭合</td></tr><tr class="odd"><td>高亮</td><td>==Highlight== 左右==闭合</td></tr><tr class="even"><td>内联公式</td><td><span class="math inline">\(a^2+b^2 = c^2\)</span> 左右$闭合</td></tr></tbody></table><h3 id="表情">表情</h3><p>win+. 打开表情菜单（表情、颜文字和符号）</p><p>:闭合直接引用表情 :smile:</p><h3 id="有限的html元素">有限的HTML元素</h3><ul><li>下划线 <code>&lt;u&gt;underline&lt;/u&gt;</code></li><li>评论 <code>&lt;!-- This is a comment.--&gt;</code></li><li>超链接 <code>&lt;a herf =&quot;www.baidu.com&quot;&gt;h&lt;/a&gt;</code></li><li>图片 <code>&lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fitem%2F201807%2F31%2F20180731224044_YYwmw.thumb.700_0.gif&amp;refer=http%3A%2F%2Fc-ssl.duitang.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1622518014&amp;t=24bfc901cf3243b67c2bf6393ce86977&quot; /&gt;</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/04/28/hello-world/"/>
    <url>/2021/04/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
